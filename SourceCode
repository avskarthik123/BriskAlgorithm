//#include "precomp.hpp"
#include <fstream>
#include <stdlib.h>
#include<cv.h>
#include<omp.h>
#include <opencv2/features2d.hpp>
//#include <opencv2/features2d/src/agast_score.hpps >
#include <vector>
#include <iostream>
#include <cstdlib>
#include <fstream>
#include <opencv2/opencv.hpp>
#include <opencv2/core.hpp>
//#include<mpi.h>
#include "pre.hpp"
#include "Agast.hpp"
//#include<open
using namespace std;
// using std::cout;
// using std::cerr;
// using std::vector;
// using std::string;

//using cv::
using namespace cv;
using namespace abb ;



// using cv::AGAST;
// using cv::AgastFeatureDetector;
// using cv::Mat;
// using cv::Point2f;
// using cv::KeyPoint;
// using cv::Scalar;
// using cv::Ptr;
// using cv::BRISK;
// using cv::AGAST;
// using cv::makePtr;
// using cv::InputArray;
// using cv::OutputArray;
// //using cv::_OVERRIDE;
//

//using cv::AGASTScore;


class BRISK_Impl1:public BRISK
{
public:

    explicit BRISK_Impl1(int thresh=30, int octaves=3, float patternScale=1.0f);

    //virtual ~BRISK_Impl1();

 void generateKernel1(const std::vector<float> &radiusList,
        const std::vector<int> &numberList, float dMax=5.85f, float dMin=8.2f,
        const std::vector<int> &indexChange=std::vector<int>());

 void detectAndCompute( InputArray image, InputArray mask,
                     CV_OUT std::vector<KeyPoint>& keypoints,
                     OutputArray descriptors,
                     bool useProvidedKeypoints ) ;//CV_OVERRIDE;


                   protected:
    void computeKeypointsNoOrientation(InputArray image, InputArray mask, std::vector<KeyPoint>& keypoints) const;
    void computeDescriptorsAndOrOrientation(InputArray image, InputArray mask, std::vector<KeyPoint>& keypoints,
                                       OutputArray descriptors, bool doDescriptors, bool doOrientation,
                                       bool useProvidedKeypoints) const;
    CV_PROP_RW int threshold;
    CV_PROP_RW int octaves;

     struct BriskPatternPoint{
        float x;         // x coordinate relative to center
        float y;         // x coordinate relative to center
        float sigma;     // Gaussian smoothing sigma
    };
    struct BriskShortPair{
        unsigned int i;  // index of the first pattern point
        unsigned int j;  // index of other pattern point
    };
    struct BriskLongPair{
        unsigned int i;  // index of the first pattern point
        unsigned int j;  // index of other pattern point
        int weighted_dx; // 1024.0/dx
        int weighted_dy; // 1024.0/dy
    };

    inline int smoothedIntensity(const cv::Mat& image,
                const cv::Mat& integral,const float key_x,
                const float key_y, const unsigned int scale,
                const unsigned int rot, const unsigned int point) const;


    BriskPatternPoint* patternPoints_;     //[i][rotation][scale]
    unsigned int points_;                 // total number of collocation points
    float* scaleList_;                     // lists the scaling per scale index [scale]
    unsigned int* sizeList_;             // lists the total pattern size per scale index [scale]
    static const unsigned int scales_;    // scales discretization
    static const float scalerange_;     // span of sizes 40->4 Octaves - else, this needs to be adjusted...
    static const unsigned int n_rot_;    // discretization of the rotation look-up

    // pairs
    int strings_;                        // number of uchars the descriptor consists of
    float dMax_;                         // short pair maximum distance
    float dMin_;                         // long pair maximum distance
    BriskShortPair* shortPairs_;         // d<_dMax
    BriskLongPair* longPairs_;             // d>_dMin
    unsigned int noShortPairs_;         // number of shortParis
    unsigned int noLongPairs_;             // number of longParis

    // general
    static const float basicSize_;



private:
  //  BRISK_Impl1(const BRISK_Impl1 &); // copy disabled
    //BRISK_Impl1& operator=(const BRISK_Impl1 &); // assign disabled


  };

  class BriskLayer1
  {
  public:
      struct CommonParams
    {
      static const int HALFSAMPLE = 0;
      static const int TWOTHIRDSAMPLE = 1;
    };

      // construct a base layer
    BriskLayer1(const cv::Mat& img, float scale = 1.0f, float offset = 0.0f);
    // derive a layer
    BriskLayer1(const BriskLayer1& layer, int mode);


    // Agast without non-max suppression
    void
    getAgastPoints(int threshold, std::vector<cv::KeyPoint>& keypoints);

    // get scores - attention, this is in layer coordinates, not scale=1 coordinates!
    inline int
    getAgastScore(int x, int y, int threshold) const;
    inline int
    getAgastScore_5_8(int x, int y, int threshold) const ;

    inline int
    getAgastScore(float xf, float yf, int threshold, float scale = 1.0f) const;

    // accessors
    inline const cv::Mat&
    img() const
    {
      return img_;
    }
    inline const cv::Mat&
    scores() const
    {
      return scores_;
    }
    inline float
    scale() const
    {
      return scale_;
    }
    inline float
    offset() const
    {
      return offset_;
    }

    // half sampling
    static inline void
    halfsample(const cv::Mat& srcimg, cv::Mat& dstimg);
    // two third sampling
    static inline void
    twothirdsample(const cv::Mat& srcimg, cv::Mat& dstimg);

  private:
    // access gray values (smoothed/interpolated)
    inline int
    value(const cv::Mat& mat, float xf, float yf, float scale) const;
    // the image
    cv::Mat img_;
    // its Agast scores
    cv::Mat_<uchar> scores_;
    // coordinate transformation
    float scale_;
    float offset_;
    // agast
    cv::Ptr<cv::AgastFeatureDetector> oast_9_16_;
    int pixel_5_8_[25];
    int pixel_9_16_[25];
  };


class BriskScaleSpace1
{
public:
   //construct telling the octaves number:
  BriskScaleSpace1(int _octaves = 3);
  ~BriskScaleSpace1();

 // construct the image pyramids
  void
  constructPyramid(const cv::Mat& image);

  // get Keypoints
  void
  getKeypoints(const int _threshold, std::vector<cv::KeyPoint>& keypoints);

protected:
  // nonmax suppression:
  inline bool
  isMax2D(const int layer, const int x_layer, const int y_layer);


inline float
  refine1D(const float s_05, const float s0, const float s05, float& max) const; // around octave
  inline float
  refine1D_1(const float s_05, const float s0, const float s05, float& max) const; // around intra
  inline float
  refine1D_2(const float s_05, const float s0, const float s05, float& max) const; // around octave 0 only
  // 2D maximum refinement:
  inline float
  subpixel2D(const int s_0_0, const int s_0_1, const int s_0_2, const int s_1_0, const int s_1_1, const int s_1_2,
             const int s_2_0, const int s_2_1, const int s_2_2, float& delta_x, float& delta_y) const;
  // 3D maximum refinement centered around (x_layer,y_layer)
  inline float
  refine3D(const int layer, const int x_layer, const int y_layer, float& x, float& y, float& scale, bool& ismax) const;


  inline float
  getScoreMaxAbove(const int layer, const int x_layer, const int y_layer, const int threshold, bool& ismax,
                   float& dx, float& dy) const;
  inline float
  getScoreMaxBelow(const int layer, const int x_layer, const int y_layer, const int threshold, bool& ismax,
                   float& dx, float& dy) const;


 // the image pyramids:
  int layers_;
  std::vector<BriskLayer1> pyramid_;

  // some constant parameters:
  static const float safetyFactor_;
  static const float basicSize_;
};







const float BRISK_Impl1::basicSize_ = 12.0f;
const unsigned int BRISK_Impl1::scales_ = 64;
const float BRISK_Impl1::scalerange_ = 30.f; // 40->4 Octaves - else, this needs to be adjusted...
const unsigned int BRISK_Impl1::n_rot_ = 1024; // discretization of the rotation look-up
const float BriskScaleSpace1::safetyFactor_ = 1.0f;
const float BriskScaleSpace1::basicSize_ = 12.0f;

BRISK_Impl1::BRISK_Impl1(int thresh, int octaves_in, float patternScale)
{
     threshold = thresh;
  octaves = octaves_in;

  std::vector<float> rList;
  std::vector<int> nList;

  // this is the standard pattern found to be suitable also
  rList.resize(5);
  nList.resize(5);
  const double f = 0.85 * patternScale;

  rList[0] = (float)(f * 0.);
  rList[1] = (float)(f * 2.9);
  rList[2] = (float)(f * 4.9);
  rList[3] = (float)(f * 7.4);
  rList[4] = (float)(f * 10.8);

  nList[0] = 1;
  nList[1] = 10;
  nList[2] = 14;
  nList[3] = 15;
  nList[4] = 20;

  generateKernel1(rList, nList, (float)(5.85 * patternScale), (float)(8.2 * patternScale));
}

void BRISK_Impl1::generateKernel1(const std::vector<float> &radiusList,
                           const std::vector<int> &numberList,
                           float dMax, float dMin,
                           const std::vector<int>& _indexChange)
{
    std::vector<int> indexChange = _indexChange;
  dMax_ = dMax;
  dMin_ = dMin;

  // get the total number of points
  const int rings = (int)radiusList.size();
  CV_Assert(radiusList.size() != 0 && radiusList.size() == numberList.size());
  points_ = 0; // remember the total number of points
  for (int ring = 0; ring < rings; ring++)
  {
    points_ += numberList[ring];                                                        //CAN USE REDUCE OPENMP
  }

  patternPoints_ = new BriskPatternPoint[points_ * scales_ * n_rot_];
  BriskPatternPoint* patternIterator = patternPoints_;               //A struct

  static const float lb_scale = (float)(std::log(scalerange_) / std::log(2.0));
  static const float lb_scale_step = lb_scale / (scales_);

  scaleList_ = new float[scales_];
  sizeList_ = new unsigned int[scales_];

   const float sigma_scale = 1.3f;

   for (unsigned int scale = 0; scale < scales_; ++scale)
    {
            scaleList_[scale] = (float)std::pow((double) 2.0, (double) (scale * lb_scale_step));
            sizeList_[scale] = 0;
            // generate the pattern points look-up
            double alpha, theta;
            for (size_t rot = 0; rot < n_rot_; ++rot)
            {
              theta = double(rot) * 2 * CV_PI / double(n_rot_); // this is the rotation of the feature
              for (int ring = 0; ring < rings; ++ring)
              {
                for (int num = 0; num < numberList[ring]; ++num)
                {
                  // the actual coordinates on the circle
                  alpha = (double(num)) * 2 * CV_PI / double(numberList[ring]);
                  patternIterator->x = (float)(scaleList_[scale] * radiusList[ring] * cos(alpha + theta)); // feature rotation plus angle of the point
                  patternIterator->y = (float)(scaleList_[scale] * radiusList[ring] * sin(alpha + theta));
                  // and the gaussian kernel sigma
                  if (ring == 0)
                  {
                    patternIterator->sigma = sigma_scale * scaleList_[scale] * 0.5f;
                  }
                  else
                  {
                    patternIterator->sigma = (float)(sigma_scale * scaleList_[scale] * (double(radiusList[ring]))
                                             * sin(CV_PI / numberList[ring]));
                  }
                  // adapt the sizeList if necessary
                  const unsigned int size = cvCeil(((scaleList_[scale] * radiusList[ring]) + patternIterator->sigma)) + 1;
                  if (sizeList_[scale] < size)
                  {
                    sizeList_[scale] = size;
                  }

                  // increment the iterator
                  ++patternIterator;
                }
              }
            }
    }

  // now also generate pairings
  shortPairs_ = new BriskShortPair[points_ * (points_ - 1) / 2];
  longPairs_ = new BriskLongPair[points_ * (points_ - 1) / 2];
  noShortPairs_ = 0;
  noLongPairs_ = 0;

    unsigned int indSize = (unsigned int)indexChange.size();
    if (indSize == 0)
      {
        indexChange.resize(points_ * (points_ - 1) / 2);
        indSize = (unsigned int)indexChange.size();

        for (unsigned int i = 0; i < indSize; i++)
          indexChange[i] = i;
      }

 const float dMin_sq = dMin_ * dMin_;
 const float dMax_sq = dMax_ * dMax_;


 for (unsigned int i = 1; i < points_; i++)
  {
    for (unsigned int j = 0; j < i; j++)
    { //(find all the pairs)
      // point pair distance:
      const float dx = patternPoints_[j].x - patternPoints_[i].x;
      const float dy = patternPoints_[j].y - patternPoints_[i].y;
      const float norm_sq = (dx * dx + dy * dy);

      if (norm_sq > dMin_sq)
      {
        // save to long pairs
        BriskLongPair& longPair = longPairs_[noLongPairs_];
        longPair.weighted_dx = int((dx / (norm_sq)) * 2048.0 + 0.5);
        longPair.weighted_dy = int((dy / (norm_sq)) * 2048.0 + 0.5);
        longPair.i = i;
        longPair.j = j;
        ++noLongPairs_;
      }

else if (norm_sq < dMax_sq)
      {
        // save to short pairs
        CV_Assert(noShortPairs_ < indSize);
        // make sure the user passes something sensible
        BriskShortPair& shortPair = shortPairs_[indexChange[noShortPairs_]];
        shortPair.j = j;
        shortPair.i = i;
        ++noShortPairs_;
      }
    }
  }
  // no bits:
  strings_ = (int) ceil((float(noShortPairs_)) / 128.0) * 4 * 4;


}

void
BRISK_Impl1::detectAndCompute( InputArray _image, InputArray _mask, std::vector<KeyPoint>& keypoints,
                              OutputArray _descriptors, bool useProvidedKeypoints)
{//cout<<"Detect and compute"<<octaves;
  bool doOrientation=true;

  // If the user specified cv::noArray(), this will yield false. Otherwise it will return true.
  bool doDescriptors = _descriptors.needed();

  computeDescriptorsAndOrOrientation(_image, _mask, keypoints, _descriptors, doDescriptors, doOrientation,
                                       useProvidedKeypoints);
}
inline bool
RoiPredicate(const float minX, const float minY, const float maxX, const float maxY, const KeyPoint& keyPt)
{
  const Point2f& pt = keyPt.pt;
  return (pt.x < minX) || (pt.x >= maxX) || (pt.y < minY) || (pt.y >= maxY);
}

void
BRISK_Impl1::computeDescriptorsAndOrOrientation(InputArray _image, InputArray _mask, std::vector<KeyPoint>& keypoints,
                                     OutputArray _descriptors, bool doDescriptors, bool doOrientation,
                                     bool useProvidedKeypoints) const
{
  Mat image = _image.getMat(), mask = _mask.getMat();
  if( image.type() != CV_8UC1 )
      cvtColor(image, image, cv::COLOR_BGR2GRAY);

    // if (!useProvidedKeypoints)
    //   cout<<"JEA";
    // //{


     doOrientation = true;
     computeKeypointsNoOrientation(_image, _mask, keypoints);
  // }

   //Remove keypoints very close to the border
  size_t ksize = keypoints.size();
  //cout<<"Keypoints :"<<keypoints.size();
  std::vector<int> kscales; // remember the scale per keypoint
  kscales.resize(ksize);
  static const float log2 = 0.693147180559945f;
  static const float lb_scalerange = (float)(std::log(scalerange_) / (log2));
  std::vector<cv::KeyPoint>::iterator beginning = keypoints.begin();
  std::vector<int>::iterator beginningkscales = kscales.begin();
  static const float basicSize06 = basicSize_ * 0.6f;

//  #pragma omp parallel for
   for (size_t k = 0; k < ksize; k++)
  {
    unsigned int scale;
      scale = std::max((int) (scales_ / lb_scalerange * (std::log(keypoints[k].size / (basicSize06)) / log2) + 0.5), 0);
      // saturate
      if (scale >= scales_)
        scale = scales_ - 1;
      kscales[k] = scale;

    const int border = sizeList_[scale];
    const int border_x = image.cols - border;
    const int border_y = image.rows - border;

    if (RoiPredicate((float)border, (float)border, (float)border_x, (float)border_y, keypoints[k]))
    {

      keypoints.erase(beginning + k);
      kscales.erase(beginningkscales + k);
      if (k == 0)
      {
        beginning = keypoints.begin();
        beginningkscales = kscales.begin();
      }
      ksize--;
      k--;
    }
  }

// first, calculate the integral image over the whole image:
  // current integral image
  cv::Mat _integral; // the integral image
  cv::integral(image, _integral);

  int* _values = new int[points_]; // for temporary use

  // resize the descriptors:
  cv::Mat descriptors;
  if (doDescriptors)
  {
    _descriptors.create((int)ksize, strings_, CV_8U);
    descriptors = _descriptors.getMat();
    descriptors.setTo(0);
  }

 // now do the extraction for all keypoints:

  // temporary variables containing gray values at sample points:
  int t1;
  int t2;
//cout<<"\nmmm"<<ksize;
  // the feature orientation
    const uchar* ptr = descriptors.ptr();
  for (size_t k = 0; k < ksize; k++)
  {
    cv::KeyPoint& kp = keypoints[k];
    const int& scale = kscales[k];
    const float& x = kp.pt.x;
    const float& y = kp.pt.y;
  //  cout<<"ComputeDescribe\n" ;
    if (doOrientation)
    {
        // get the gray values in the unrotated pattern
        #pragma omp prallel for
        for (unsigned int i = 0; i < points_; i++)
        {
            _values[i] = smoothedIntensity(image, _integral, x, y, scale, 0, i);
        }
        int direction0=0;
        int direction1=0;

         // now iterate through the long pairings
        const BriskLongPair* max = longPairs_ + noLongPairs_;
        for (BriskLongPair* iter = longPairs_; iter < max; ++iter)
        {
            CV_Assert(iter->i < points_ && iter->j < points_);
          t1 = *(_values + iter->i);
          t2 = *(_values + iter->j);

          const int delta_t = (t1 - t2);
          // update the direction:
          const int tmp0 = delta_t * (iter->weighted_dx) / 1024;                            //parlalize
          const int tmp1 = delta_t * (iter->weighted_dy) / 1024;
          direction0 += tmp0;
          direction1 += tmp1;
        }        kp.angle = (float)(atan2((float) direction1, (float) direction0) / CV_PI * 180.0);

        if (!doDescriptors)
        {
          if (kp.angle < 0)
            kp.angle += 360.f;
        }
    }

    if (!doDescriptors)
      continue;

     int theta;
    if (kp.angle==-1)
    {
         // don't compute the gradient direction, just assign a rotation of 0
        theta = 0;
    }
    else
    {
         theta = (int) (n_rot_ * (kp.angle / (360.0)) + 0.5);
        if (theta < 0)
          theta += n_rot_;
        if (theta >= int(n_rot_))
          theta -= n_rot_;
    }

    if(kp.angle<0)
        kp.angle+=360.f;
    // now also extract the stuff for the actual direction:
    // let us compute the smoothed values
    int shifter = 0;
    //unsigned int mean=0;
    // get the gray values in the rotated pattern
    #pragma omp parallel for
    for (unsigned int i = 0; i < points_; i++)
    {
        _values[i] = smoothedIntensity(image, _integral, x, y, scale, theta, i);
    }


    // now iterate through all the short pairings
    unsigned int* ptr2 = (unsigned int*) ptr;

    const BriskShortPair* max = shortPairs_ + noShortPairs_;
    for (BriskShortPair* iter = shortPairs_; iter < max; ++iter)
    {
        CV_Assert(iter->i < points_ && iter->j < points_);
      t1 = *(_values + iter->i);
      t2 = *(_values + iter->j);
      if (t1 > t2)
      {
        *ptr2 |= ((1) << shifter);

      } // else already initialized with zero
      // take care of the iterators:
       ++shifter;
      if (shifter == 32)
      {
        shifter = 0;
        ++ptr2;
      }
      //cout<<"PTR"<<ptr2;

    }
ptr+=strings_;

}

 // clean-up
  delete[] _values;
}

void
BRISK_Impl1::computeKeypointsNoOrientation(InputArray _image, InputArray _mask, std::vector<KeyPoint>& keypoints) const
{
  //cout<<"JERERAF";
  Mat image = _image.getMat(), mask = _mask.getMat();
  if( image.type() != CV_8UC1 )
      cvtColor(_image, image, cv::COLOR_BGR2GRAY);
  BriskScaleSpace1 BriskScaleSpace1(octaves);
  BriskScaleSpace1.constructPyramid(image);
  BriskScaleSpace1.getKeypoints(threshold, keypoints);

  // remove invalid points
  //cv::KeyPointsFilter::runByPixelsMask(keypoints, mask);
}


inline int
BRISK_Impl1::smoothedIntensity(const cv::Mat& image, const cv::Mat& integral, const float key_x,
                                            const float key_y, const unsigned int scale, const unsigned int rot,
                                            const unsigned int point) const
{
     // get the float position
  const BriskPatternPoint& briskPoint = patternPoints_[scale * n_rot_ * points_ + rot * points_ + point];
  const float xf = briskPoint.x + key_x;
  const float yf = briskPoint.y + key_y;
  const int x = int(xf);
  const int y = int(yf);
  const int& imagecols = image.cols;


  // get the sigma:
  const float sigma_half = briskPoint.sigma;
  const float area = 4.0f * sigma_half * sigma_half;

  // calculate output:
  int ret_val;
  if (sigma_half < 0.5)
  {
    //interpolation multipliers:
    const int r_x = (int)((xf - x) * 1024);
    const int r_y = (int)((yf - y) * 1024);
    const int r_x_1 = (1024 - r_x);
    const int r_y_1 = (1024 - r_y);
    const uchar* ptr = &image.at<uchar>(y, x);
    size_t step = image.step;
    // just interpolate:
    ret_val = r_x_1 * r_y_1 * ptr[0] + r_x * r_y_1 * ptr[1] +
              r_x * r_y * ptr[step] + r_x_1 * r_y * ptr[step+1];
    return (ret_val + 512) / 1024;
  }

  // this is the standard case (simple, not speed optimized yet):

  // scaling:
  const int scaling = (int)(4194304.0 / area);
  const int scaling2 = int(float(scaling) * area / 1024.0);
  CV_Assert(scaling2 != 0);

  // the integral image is larger:
  const int integralcols = imagecols + 1;

  // calculate borders
  const float x_1 = xf - sigma_half;
  const float x1 = xf + sigma_half;
  const float y_1 = yf - sigma_half;
  const float y1 = yf + sigma_half;

  const int x_left = int(x_1 + 0.5);
  const int y_top = int(y_1 + 0.5);
  const int x_right = int(x1 + 0.5);
  const int y_bottom = int(y1 + 0.5);

  // overlap area - multiplication factors:
  const float r_x_1 = float(x_left) - x_1 + 0.5f;
  const float r_y_1 = float(y_top) - y_1 + 0.5f;
  const float r_x1 = x1 - float(x_right) + 0.5f;
  const float r_y1 = y1 - float(y_bottom) + 0.5f;
  const int dx = x_right - x_left - 1;
  const int dy = y_bottom - y_top - 1;
  const int A = (int)((r_x_1 * r_y_1) * scaling);
  const int B = (int)((r_x1 * r_y_1) * scaling);
  const int C = (int)((r_x1 * r_y1) * scaling);
  const int D = (int)((r_x_1 * r_y1) * scaling);
  const int r_x_1_i = (int)(r_x_1 * scaling);
  const int r_y_1_i = (int)(r_y_1 * scaling);
  const int r_x1_i = (int)(r_x1 * scaling);
  const int r_y1_i = (int)(r_y1 * scaling);

  if (dx + dy > 2)
  {
    // now the calculation:
    const uchar* ptr = image.ptr() + x_left + imagecols * y_top;
    // first the corners:
    ret_val = A * int(*ptr);
    ptr += dx + 1;
    ret_val += B * int(*ptr);
    ptr += dy * imagecols + 1;
    ret_val += C * int(*ptr);
    ptr -= dx + 1;
    ret_val += D * int(*ptr);

    // next the edges:
    const int* ptr_integral = integral.ptr<int>() + x_left + integralcols * y_top + 1;
    // find a simple path through the different surface corners
    const int tmp1 = (*ptr_integral);
    ptr_integral += dx;
    const int tmp2 = (*ptr_integral);
    ptr_integral += integralcols;
    const int tmp3 = (*ptr_integral);
    ptr_integral++;
    const int tmp4 = (*ptr_integral);
    ptr_integral += dy * integralcols;
    const int tmp5 = (*ptr_integral);
    ptr_integral--;
    const int tmp6 = (*ptr_integral);
    ptr_integral += integralcols;
    const int tmp7 = (*ptr_integral);
    ptr_integral -= dx;
    const int tmp8 = (*ptr_integral);
    ptr_integral -= integralcols;
    const int tmp9 = (*ptr_integral);
    ptr_integral--;
    const int tmp10 = (*ptr_integral);
    ptr_integral -= dy * integralcols;
    const int tmp11 = (*ptr_integral);
    ptr_integral++;
    const int tmp12 = (*ptr_integral);

    // assign the weighted surface integrals:
    const int upper = (tmp3 - tmp2 + tmp1 - tmp12) * r_y_1_i;
    const int middle = (tmp6 - tmp3 + tmp12 - tmp9) * scaling;
    const int left = (tmp9 - tmp12 + tmp11 - tmp10) * r_x_1_i;
    const int right = (tmp5 - tmp4 + tmp3 - tmp6) * r_x1_i;
    const int bottom = (tmp7 - tmp6 + tmp9 - tmp8) * r_y1_i;

    return (ret_val + upper + middle + left + right + bottom + scaling2 / 2) / scaling2;
  }

  // now the calculation:
  const uchar* ptr = image.ptr() + x_left + imagecols * y_top;
  // first row:
  ret_val = A * int(*ptr);
  ptr++;
  const uchar* end1 = ptr + dx;
  for (; ptr < end1; ptr++)
  {
    ret_val += r_y_1_i * int(*ptr);
  }
  ret_val += B * int(*ptr);
  // middle ones:
  ptr += imagecols - dx - 1;
  const uchar* end_j = ptr + dy * imagecols;
  for (; ptr < end_j; ptr += imagecols - dx - 1)
  {
    ret_val += r_x_1_i * int(*ptr);
    ptr++;
    const uchar* end2 = ptr + dx;
    for (; ptr < end2; ptr++)
    {
      ret_val += int(*ptr) * scaling;
    }
    ret_val += r_x1_i * int(*ptr);
  }
  // last row:
  ret_val += D * int(*ptr);
  ptr++;
  const uchar* end3 = ptr + dx;
  for (; ptr < end3; ptr++)
  {
    ret_val += r_y1_i * int(*ptr);
  }
  ret_val += C * int(*ptr);

  return (ret_val + scaling2 / 2) / scaling2;
}






BriskScaleSpace1::BriskScaleSpace1(int _octaves)
{
  if (_octaves == 0)
    layers_ = 1;
  else
    layers_ = 2 * _octaves;
 //cout<<"Ocataves and Layers"<<_octaves<<layers_<<"\n";
}
BriskScaleSpace1::~BriskScaleSpace1()
{

}

//construct the image pyramids
void
BriskScaleSpace1::constructPyramid(const cv::Mat& image)
{

  // set correct size:
  pyramid_.clear();

   // fill the pyramid:
  pyramid_.push_back(BriskLayer1(image.clone()));
  if (layers_ > 1)
  {
    pyramid_.push_back(BriskLayer1(pyramid_.back(), BriskLayer1::CommonParams::TWOTHIRDSAMPLE));
  }
  const int octaves2 = layers_;

  for (uchar i = 2; i < octaves2; i += 2)
  {
    pyramid_.push_back(BriskLayer1(pyramid_[i - 2], BriskLayer1::CommonParams::HALFSAMPLE));
    pyramid_.push_back(BriskLayer1(pyramid_[i - 1], BriskLayer1::CommonParams::HALFSAMPLE));
  }

}

 void
BriskScaleSpace1::getKeypoints(const int threshold_, std::vector<cv::KeyPoint>& keypoints)
{
 // make sure keypoints is empty
  keypoints.resize(0);
  keypoints.reserve(2000);

  // assign thresholds
  int safeThreshold_ = (int)(threshold_ * safetyFactor_);
  std::vector<std::vector<cv::KeyPoint> > agastPoints;
  agastPoints.resize(layers_);
  #pragma omp parallel for
   for (int i = 0; i < layers_; i++)
  { //cout<<"heu\n";
    // call OAST16_9 without nms
    BriskLayer1& l = pyramid_[i];                        //parallelize
    l.getAgastPoints(safeThreshold_, agastPoints[i]);

  }

   if (layers_ == 1)
  {
    // just do a simple 2d subpixel refinement...
    const size_t num = agastPoints[0].size();
    for (size_t n = 0; n < num; n++)          //parallelize
    {
      const cv::Point2f& point = agastPoints.at(0)[n].pt;

      if (!isMax2D(0, (int)point.x, (int)point.y))
        continue;

        // let's do the subpixel and float scale refinement:
      BriskLayer1& l = pyramid_[0];
      int s_0_0 = l.getAgastScore(point.x - 1, point.y - 1, 1);
      int s_1_0 = l.getAgastScore(point.x, point.y - 1, 1);
      int s_2_0 = l.getAgastScore(point.x + 1, point.y - 1, 1);
      int s_2_1 = l.getAgastScore(point.x + 1, point.y, 1);
      int s_1_1 = l.getAgastScore(point.x, point.y, 1);
      int s_0_1 = l.getAgastScore(point.x - 1, point.y, 1);
      int s_0_2 = l.getAgastScore(point.x - 1, point.y + 1, 1);
      int s_1_2 = l.getAgastScore(point.x, point.y + 1, 1);
      int s_2_2 = l.getAgastScore(point.x + 1, point.y + 1, 1);
      float delta_x, delta_y;
      float max = subpixel2D(s_0_0, s_0_1, s_0_2, s_1_0, s_1_1, s_1_2, s_2_0, s_2_1, s_2_2, delta_x, delta_y);


      keypoints.push_back(cv::KeyPoint(float(point.x) + delta_x, float(point.y) + delta_y, basicSize_, -1, max, 0));

      //cout<<"PRint"<<keypoints.size();

    }
    return;

  }

 float x, y, scale, score;
  #pragma omp parallel for
  for (int i = 0; i < layers_; i++)
  {
    BriskLayer1& l = pyramid_[i];

    const size_t num = agastPoints[i].size();
    //cout<<agastPoints[i];
    if (i == layers_ - 1)
    {
      for (size_t n = 0; n < num; n++)
      {
        const cv::Point2f& point = agastPoints.at(i)[n].pt;
        // consider only 2D maxima...
        if (!isMax2D(i, (int)point.x, (int)point.y))
          continue;
        bool ismax;
        float dx, dy;
        getScoreMaxBelow(i, (int)point.x, (int)point.y, l.getAgastScore(point.x, point.y, safeThreshold_), ismax, dx, dy);
        if (!ismax)
          continue;
        int s_0_0, s_0_1, s_0_2, s_1_0, s_1_1, s_1_2, s_2_0, s_2_1, s_2_2;
        // get the patch on this layer:
        #pragma omp parallel sections
        {
        #pragma omp section
        s_0_0 = l.getAgastScore(point.x - 1, point.y - 1, 1);
        #pragma omp section
        s_1_0 = l.getAgastScore(point.x, point.y - 1, 1);
        #pragma omp section
        s_2_0 = l.getAgastScore(point.x + 1, point.y - 1, 1);
        #pragma omp section
        s_2_1 = l.getAgastScore(point.x + 1, point.y, 1);
        #pragma omp section
        s_1_1 = l.getAgastScore(point.x, point.y, 1);
        #pragma omp section
        s_0_1 = l.getAgastScore(point.x - 1, point.y, 1);
        #pragma omp section
        s_0_2 = l.getAgastScore(point.x - 1, point.y + 1, 1);
        #pragma omp section
        s_1_2 = l.getAgastScore(point.x, point.y + 1, 1);
        #pragma omp section
        s_2_2 = l.getAgastScore(point.x + 1, point.y + 1, 1);
        }

        float delta_x, delta_y;
        float max = subpixel2D(s_0_0, s_0_1, s_0_2, s_1_0, s_1_1, s_1_2, s_2_0, s_2_1, s_2_2, delta_x, delta_y);

        // store:
        keypoints.push_back(
            cv::KeyPoint((float(point.x) + delta_x) * l.scale() + l.offset(),
                         (float(point.y) + delta_y) * l.scale() + l.offset(), basicSize_ * l.scale(), -1, max, i));
        //cout<<"Print"<<keypoints.size();
      }
    }

  else
    {
      // not the last layer:
      for (size_t n = 0; n < num; n++)
      {
          const cv::Point2f& point = agastPoints.at(i)[n].pt;

        // first check if it is a maximum:
        if (!isMax2D(i, (int)point.x, (int)point.y))
          continue;

        // let's do the subpixel and float scale refinement:
        bool ismax=false;
        score = refine3D(i, (int)point.x, (int)point.y, x, y, scale, ismax);
        if (!ismax)
        {
          continue;
        }

        // finally store the detected keypoint:
        if (score > float(threshold_))
        {
          keypoints.push_back(cv::KeyPoint(x, y, basicSize_ * scale, -1, score, i));
        }
      }
    }
  }

  //cout<<"AgastPoints"<<agastPoints.size();
}

inline bool
BriskScaleSpace1::isMax2D(const int layer, const int x_layer, const int y_layer)
{
  const cv::Mat& scores = pyramid_[layer].scores();
  const int scorescols = scores.cols;
  const uchar* data = scores.ptr() + y_layer * scorescols + x_layer;
  // decision tree:
  const uchar center = (*data);
  data--;
  const uchar s_10 = *data;
  if (center < s_10)
    return false;
  data += 2;
  const uchar s10 = *data;
  if (center < s10)
    return false;
  data -= (scorescols + 1);

  const uchar s0_1 = *data;
  if (center < s0_1)
    return false;
  data += 2 * scorescols;             //SEction parllalizaton may be
  const uchar s01 = *data;
  if (center < s01)
    return false;
  data--;
  const uchar s_11 = *data;
  if (center < s_11)
    return false;
  data += 2;
  const uchar s11 = *data;
  if (center < s11)
    return false;
  data -= 2 * scorescols;
  const uchar s1_1 = *data;
  if (center < s1_1)
    return false;
  data -= 2;
  const uchar s_1_1 = *data;
  if (center < s_1_1)
    return false;

  // reject neighbor maxima
   std::vector<int> delta;
  // put together a list of 2d-offsets to where the maximum is also reached
  if (center == s_1_1)
  {
    delta.push_back(-1);
    delta.push_back(-1);
  }
  if (center == s0_1)
  {
    delta.push_back(0);
    delta.push_back(-1);
  }
  if (center == s1_1)
  {
    delta.push_back(1);
    delta.push_back(-1);
  }
  if (center == s_10)
  {
    delta.push_back(-1);
    delta.push_back(0);
  }
  if (center == s10)
  {
    delta.push_back(1);
    delta.push_back(0);
  }
  if (center == s_11)
  {
    delta.push_back(-1);
    delta.push_back(1);
  }
  if (center == s01)
  {
    delta.push_back(0);
    delta.push_back(1);
  }
  if (center == s11)
  {
    delta.push_back(1);
    delta.push_back(1);
  }

  const unsigned int deltasize = (unsigned int)delta.size();
  if (deltasize != 0)
  {
    // in this case, we have to analyze the situation more carefully:
    // the values are gaussian blurred and then we really decide
    int smoothedcenter = 4 * center + 2 * (s_10 + s10 + s0_1 + s01) + s_1_1 + s1_1 + s_11 + s11;
    for (unsigned int i = 0; i < deltasize; i += 2)
    {
      data = scores.ptr() + (y_layer - 1 + delta[i + 1]) * scorescols + x_layer + delta[i] - 1;
      int othercenter = *data;
      data++;
      othercenter += 2 * (*data);
      data++;
      othercenter += *data;
      data += scorescols;
      othercenter += 2 * (*data);
      data--;
      othercenter += 4 * (*data);
      data--;
      othercenter += 2 * (*data);
      data += scorescols;
      othercenter += *data;
      data++;
      othercenter += 2 * (*data);
      data++;
      othercenter += *data;
      if (othercenter > smoothedcenter)
        return false;
    }
  }
  return true;
}

inline float
BriskScaleSpace1::refine1D(const float s_05, const float s0, const float s05, float& max) const
{
  int i_05 = int(1024.0 * s_05 + 0.5);
  int i0 = int(1024.0 * s0 + 0.5);
  int i05 = int(1024.0 * s05 + 0.5);

  //   16.0000  -24.0000    8.0000
  //  -40.0000   54.0000  -14.0000
  //   24.0000  -27.0000    6.0000

  int three_a = 16 * i_05 - 24 * i0 + 8 * i05;
  // second derivative must be negative:
 if (three_a >= 0)
 {
   if (s0 >= s_05 && s0 >= s05)
   {
     max = s0;
     return 1.0f;
   }
   if (s_05 >= s0 && s_05 >= s05)
   {
     max = s_05;
     return 0.75f;
   }
   if (s05 >= s0 && s05 >= s_05)
   {
     max = s05;
     return 1.5f;
   }
 }
  // calculate max location:
  int three_b = -40 * i_05 + 54 * i0 - 14 * i05;
  float ret_val = -float(three_b) / float(2 * three_a);
  // saturate and return
  if (ret_val < 0.75)
    ret_val = 0.75;
  else if (ret_val > 1.5)
    ret_val = 1.5; // allow to be slightly off bounds ...?
  int three_c = +24 * i_05 - 27 * i0 + 6 * i05;
  max = float(three_c) + float(three_a) * ret_val * ret_val + float(three_b) * ret_val;
  max /= 3072.0f;
  return ret_val;
}

inline float
BriskScaleSpace1::refine1D_1(const float s_05, const float s0, const float s05, float& max) const
{
  int i_05 = int(1024.0 * s_05 + 0.5);
  int i0 = int(1024.0 * s0 + 0.5);
  int i05 = int(1024.0 * s05 + 0.5);

  //  4.5000   -9.0000    4.5000
  //-10.5000   18.0000   -7.5000
  //  6.0000   -8.0000    3.0000

  int two_a = 9 * i_05 - 18 * i0 + 9 * i05;
  // second derivative must be negative:
  if (two_a >= 0)
  {
    if (s0 >= s_05 && s0 >= s05)
    {
      max = s0;
      return 1.0f;
    }
    if (s_05 >= s0 && s_05 >= s05)
    {
      max = s_05;
      return 0.6666666666666666666666666667f;
    }
    if (s05 >= s0 && s05 >= s_05)
    {
      max = s05;
      return 1.3333333333333333333333333333f;
    }
  }

  int two_b = -21 * i_05 + 36 * i0 - 15 * i05;
  // calculate max location:
  float ret_val = -float(two_b) / float(2 * two_a);
  // saturate and return
  if (ret_val < 0.6666666666666666666666666667f)
    ret_val = 0.666666666666666666666666667f;
  else if (ret_val > 1.33333333333333333333333333f)
    ret_val = 1.333333333333333333333333333f;
  int two_c = +12 * i_05 - 16 * i0 + 6 * i05;
  max = float(two_c) + float(two_a) * ret_val * ret_val + float(two_b) * ret_val;
  max /= 2048.0f;
  return ret_val;
}


inline float
BriskScaleSpace1::refine1D_2(const float s_05, const float s0, const float s05, float& max) const
{
  int i_05 = int(1024.0 * s_05 + 0.5);
  int i0 = int(1024.0 * s0 + 0.5);
  int i05 = int(1024.0 * s05 + 0.5);

  //   18.0000  -30.0000   12.0000
  //  -45.0000   65.0000  -20.0000
  //   27.0000  -30.0000    8.0000

  int a = 2 * i_05 - 4 * i0 + 2 * i05;
  // second derivative must be negative:
  if (a >= 0)
  {
    if (s0 >= s_05 && s0 >= s05)
    {
      max = s0;
      return 1.0f;
    }
    if (s_05 >= s0 && s_05 >= s05)
    {
      max = s_05;
      return 0.7f;
    }
    if (s05 >= s0 && s05 >= s_05)
    {
      max = s05;
      return 1.5f;
    }
  }

  int b = -5 * i_05 + 8 * i0 - 3 * i05;
  // calculate max location:
  float ret_val = -float(b) / float(2 * a);
  // saturate and return
  if (ret_val < 0.7f)
    ret_val = 0.7f;
  else if (ret_val > 1.5f)
    ret_val = 1.5f; // allow to be slightly off bounds ...?
  int c = +3 * i_05 - 3 * i0 + 1 * i05;
  max = float(c) + float(a) * ret_val * ret_val + float(b) * ret_val;
  max /= 1024;
  return ret_val;
}


inline float
BriskScaleSpace1::subpixel2D(const int s_0_0, const int s_0_1, const int s_0_2, const int s_1_0, const int s_1_1,
                            const int s_1_2, const int s_2_0, const int s_2_1, const int s_2_2, float& delta_x,
                            float& delta_y) const
{

  // the coefficients of the 2d quadratic function least-squares fit:
  int tmp1 = s_0_0 + s_0_2 - 2 * s_1_1 + s_2_0 + s_2_2;
  int coeff1 = 3 * (tmp1 + s_0_1 - ((s_1_0 + s_1_2) << 1) + s_2_1);
  int coeff2 = 3 * (tmp1 - ((s_0_1 + s_2_1) << 1) + s_1_0 + s_1_2);
  int tmp2 = s_0_2 - s_2_0;
  int tmp3 = (s_0_0 + tmp2 - s_2_2);
  int tmp4 = tmp3 - 2 * tmp2;
  int coeff3 = -3 * (tmp3 + s_0_1 - s_2_1);
  int coeff4 = -3 * (tmp4 + s_1_0 - s_1_2);
  int coeff5 = (s_0_0 - s_0_2 - s_2_0 + s_2_2) << 2;
  int coeff6 = -(s_0_0 + s_0_2 - ((s_1_0 + s_0_1 + s_1_2 + s_2_1) << 1) - 5 * s_1_1 + s_2_0 + s_2_2) << 1;

  // 2nd derivative test:
  int H_det = 4 * coeff1 * coeff2 - coeff5 * coeff5;

  if (H_det == 0)
  {
    delta_x = 0.0f;
    delta_y = 0.0f;
    return float(coeff6) / 18.0f;
  }

  if (!(H_det > 0 && coeff1 < 0))
  {
    // The maximum must be at the one of the 4 patch corners.
    int tmp_max = coeff3 + coeff4 + coeff5;
    delta_x = 1.0f;
    delta_y = 1.0f;

    int tmp = -coeff3 + coeff4 - coeff5;
    if (tmp > tmp_max)
    {
      tmp_max = tmp;
      delta_x = -1.0f;
      delta_y = 1.0f;
    }
    tmp = coeff3 - coeff4 - coeff5;
    if (tmp > tmp_max)
    {
      tmp_max = tmp;
      delta_x = 1.0f;
      delta_y = -1.0f;
    }
    tmp = -coeff3 - coeff4 + coeff5;
    if (tmp > tmp_max)
    {
      tmp_max = tmp;
      delta_x = -1.0f;
      delta_y = -1.0f;
    }
    return float(tmp_max + coeff1 + coeff2 + coeff6) / 18.0f;
  }

  // this is hopefully the normal outcome of the Hessian test
  delta_x = float(2 * coeff2 * coeff3 - coeff4 * coeff5) / float(-H_det);
  delta_y = float(2 * coeff1 * coeff4 - coeff3 * coeff5) / float(-H_det);
  // TODO: this is not correct, but easy, so perform a real boundary maximum search:
  bool tx = false;
  bool tx_ = false;
  bool ty = false;
  bool ty_ = false;
  if (delta_x > 1.0)
    tx = true;
  else if (delta_x < -1.0)
    tx_ = true;
  if (delta_y > 1.0)
    ty = true;
  if (delta_y < -1.0)
    ty_ = true;

  if (tx || tx_ || ty || ty_)
  {
    // get two candidates:
    float delta_x1 = 0.0f, delta_x2 = 0.0f, delta_y1 = 0.0f, delta_y2 = 0.0f;
    if (tx)
    {
      delta_x1 = 1.0f;
      delta_y1 = -float(coeff4 + coeff5) / float(2 * coeff2);
      if (delta_y1 > 1.0f)
        delta_y1 = 1.0f;
      else if (delta_y1 < -1.0f)
        delta_y1 = -1.0f;
    }
    else if (tx_)
    {
      delta_x1 = -1.0f;
      delta_y1 = -float(coeff4 - coeff5) / float(2 * coeff2);
      if (delta_y1 > 1.0f)
        delta_y1 = 1.0f;
      else if (delta_y1 < -1.0)
        delta_y1 = -1.0f;
    }
    if (ty)
    {
      delta_y2 = 1.0f;
      delta_x2 = -float(coeff3 + coeff5) / float(2 * coeff1);
      if (delta_x2 > 1.0f)
        delta_x2 = 1.0f;
      else if (delta_x2 < -1.0f)
        delta_x2 = -1.0f;
    }
    else if (ty_)
    {
      delta_y2 = -1.0f;
      delta_x2 = -float(coeff3 - coeff5) / float(2 * coeff1);
      if (delta_x2 > 1.0f)
        delta_x2 = 1.0f;
      else if (delta_x2 < -1.0f)
        delta_x2 = -1.0f;
    }
    // insert both options for evaluation which to pick
    float max1 = (coeff1 * delta_x1 * delta_x1 + coeff2 * delta_y1 * delta_y1 + coeff3 * delta_x1 + coeff4 * delta_y1
                  + coeff5 * delta_x1 * delta_y1 + coeff6)
                 / 18.0f;
    float max2 = (coeff1 * delta_x2 * delta_x2 + coeff2 * delta_y2 * delta_y2 + coeff3 * delta_x2 + coeff4 * delta_y2
                  + coeff5 * delta_x2 * delta_y2 + coeff6)
                 / 18.0f;
    if (max1 > max2)
    {
      delta_x = delta_x1;
      delta_y = delta_y1;
      return max1;
    }
    else
    {
      delta_x = delta_x2;
      delta_y = delta_y2;
      return max2;
    }
  }

  // this is the case of the maximum inside the boundaries:
  return (coeff1 * delta_x * delta_x + coeff2 * delta_y * delta_y + coeff3 * delta_x + coeff4 * delta_y
          + coeff5 * delta_x * delta_y + coeff6)
         / 18.0f;
}

inline float
BriskScaleSpace1::refine3D(const int layer, const int x_layer, const int y_layer, float& x, float& y, float& scale,
                          bool& ismax) const
{
  ismax = true;
  const BriskLayer1& thisLayer = pyramid_[layer];
  const int center = thisLayer.getAgastScore(x_layer, y_layer, 1);

  float delta_x_above = 0, delta_y_above = 0;
  float max_above = getScoreMaxAbove(layer, x_layer, y_layer, center, ismax, delta_x_above, delta_y_above);

  if (!ismax)
    return 0.0f;

  float max; // to be returned

  if (layer % 2 == 0)
  { // on octave
    // treat the patch below:
    float delta_x_below, delta_y_below;
    float max_below_float;
    int max_below = 0;
    if (layer == 0)
    {
      // guess the lower intra octave...
      const BriskLayer1& l = pyramid_[0];
      int s_0_0 = l.getAgastScore_5_8(x_layer - 1, y_layer - 1, 1);
      max_below = s_0_0;
      int s_1_0 = l.getAgastScore_5_8(x_layer, y_layer - 1, 1);
      max_below = std::max(s_1_0, max_below);
      int s_2_0 = l.getAgastScore_5_8(x_layer + 1, y_layer - 1, 1);
      max_below = std::max(s_2_0, max_below);
      int s_2_1 = l.getAgastScore_5_8(x_layer + 1, y_layer, 1);
      max_below = std::max(s_2_1, max_below);
      int s_1_1 = l.getAgastScore_5_8(x_layer, y_layer, 1);
      max_below = std::max(s_1_1, max_below);
      int s_0_1 = l.getAgastScore_5_8(x_layer - 1, y_layer, 1);
      max_below = std::max(s_0_1, max_below);
      int s_0_2 = l.getAgastScore_5_8(x_layer - 1, y_layer + 1, 1);
      max_below = std::max(s_0_2, max_below);
      int s_1_2 = l.getAgastScore_5_8(x_layer, y_layer + 1, 1);
      max_below = std::max(s_1_2, max_below);
      int s_2_2 = l.getAgastScore_5_8(x_layer + 1, y_layer + 1, 1);
      max_below = std::max(s_2_2, max_below);


      subpixel2D(s_0_0, s_0_1, s_0_2, s_1_0, s_1_1, s_1_2, s_2_0, s_2_1, s_2_2, delta_x_below, delta_y_below);
      max_below_float = (float)max_below;
    }
    else
    {
      max_below_float = getScoreMaxBelow(layer, x_layer, y_layer, center, ismax, delta_x_below, delta_y_below);
      if (!ismax)
        return 0;
    }

    // get the patch on this layer:
    int s_0_0 = thisLayer.getAgastScore(x_layer - 1, y_layer - 1, 1);
    int s_1_0 = thisLayer.getAgastScore(x_layer, y_layer - 1, 1);
    int s_2_0 = thisLayer.getAgastScore(x_layer + 1, y_layer - 1, 1);
    int s_2_1 = thisLayer.getAgastScore(x_layer + 1, y_layer, 1);
    int s_1_1 = thisLayer.getAgastScore(x_layer, y_layer, 1);
    int s_0_1 = thisLayer.getAgastScore(x_layer - 1, y_layer, 1);
    int s_0_2 = thisLayer.getAgastScore(x_layer - 1, y_layer + 1, 1);
    int s_1_2 = thisLayer.getAgastScore(x_layer, y_layer + 1, 1);
    int s_2_2 = thisLayer.getAgastScore(x_layer + 1, y_layer + 1, 1);
    float delta_x_layer, delta_y_layer;
    float max_layer = subpixel2D(s_0_0, s_0_1, s_0_2, s_1_0, s_1_1, s_1_2, s_2_0, s_2_1, s_2_2, delta_x_layer,
                                 delta_y_layer);
//RElative scales
    if (layer == 0)
    {
      scale = refine1D_2(max_below_float, std::max(float(center), max_layer), max_above, max);
    }
    else
      scale = refine1D(max_below_float, std::max(float(center), max_layer), max_above, max);

    if (scale > 1.0)
    {
      // interpolate the position:
      const float r0 = (1.5f - scale) / .5f;
      const float r1 = 1.0f - r0;
      x = (r0 * delta_x_layer + r1 * delta_x_above + float(x_layer)) * thisLayer.scale() + thisLayer.offset();
      y = (r0 * delta_y_layer + r1 * delta_y_above + float(y_layer)) * thisLayer.scale() + thisLayer.offset();
    }

    else
    {
      if (layer == 0)
      {
        // interpolate the position:
        const float r0 = (scale - 0.5f) / 0.5f;
        const float r_1 = 1.0f - r0;
        x = r0 * delta_x_layer + r_1 * delta_x_below + float(x_layer);
        y = r0 * delta_y_layer + r_1 * delta_y_below + float(y_layer);
      }
      else
      {
        // interpolate the position:
        const float r0 = (scale - 0.75f) / 0.25f;
        const float r_1 = 1.0f - r0;
        x = (r0 * delta_x_layer + r_1 * delta_x_below + float(x_layer)) * thisLayer.scale() + thisLayer.offset();
        y = (r0 * delta_y_layer + r_1 * delta_y_below + float(y_layer)) * thisLayer.scale() + thisLayer.offset();
      }
    }
  }
  else
  {
    // on intra
    // check the patch below:
    float delta_x_below, delta_y_below;
    float max_below = getScoreMaxBelow(layer, x_layer, y_layer, center, ismax, delta_x_below, delta_y_below);
    if (!ismax)
      return 0.0f;

      // get the patch on this layer:
     int s_0_0 = thisLayer.getAgastScore(x_layer - 1, y_layer - 1, 1);
     int s_1_0 = thisLayer.getAgastScore(x_layer, y_layer - 1, 1);
     int s_2_0 = thisLayer.getAgastScore(x_layer + 1, y_layer - 1, 1);
     int s_2_1 = thisLayer.getAgastScore(x_layer + 1, y_layer, 1);
     int s_1_1 = thisLayer.getAgastScore(x_layer, y_layer, 1);
     int s_0_1 = thisLayer.getAgastScore(x_layer - 1, y_layer, 1);
     int s_0_2 = thisLayer.getAgastScore(x_layer - 1, y_layer + 1, 1);
     int s_1_2 = thisLayer.getAgastScore(x_layer, y_layer + 1, 1);
     int s_2_2 = thisLayer.getAgastScore(x_layer + 1, y_layer + 1, 1);
     float delta_x_layer, delta_y_layer;
     float max_layer = subpixel2D(s_0_0, s_0_1, s_0_2, s_1_0, s_1_1, s_1_2, s_2_0, s_2_1, s_2_2, delta_x_layer,
                                  delta_y_layer);

     // calculate the relative scale (1D maximum):
     scale = refine1D_1(max_below, std::max(float(center), max_layer), max_above, max);
     if (scale > 1.0)
     {
       // interpolate the position:
       const float r0 = 4.0f - scale * 3.0f;
       const float r1 = 1.0f - r0;
       x = (r0 * delta_x_layer + r1 * delta_x_above + float(x_layer)) * thisLayer.scale() + thisLayer.offset();
       y = (r0 * delta_y_layer + r1 * delta_y_above + float(y_layer)) * thisLayer.scale() + thisLayer.offset();
     }
     else
     {
       // interpolate the position:
       const float r0 = scale * 3.0f - 2.0f;
       const float r_1 = 1.0f - r0;
       x = (r0 * delta_x_layer + r_1 * delta_x_below + float(x_layer)) * thisLayer.scale() + thisLayer.offset();
       y = (r0 * delta_y_layer + r_1 * delta_y_below + float(y_layer)) * thisLayer.scale() + thisLayer.offset();
     }
   }

   // calculate the absolute scale:
   scale *= thisLayer.scale();

   // that's it, return the refined maximum:
   return max;
 }


 inline float
 BriskScaleSpace1::getScoreMaxAbove(const int layer, const int x_layer, const int y_layer, const int threshold,
                                   bool& ismax, float& dx, float& dy) const
 {

   ismax = false;
   // relevant floating point coordinates
   float x_1;
   float x1;
   float y_1;
   float y1;

   // the layer above
   CV_Assert(layer + 1 < layers_);
   const BriskLayer1& layerAbove = pyramid_[layer + 1];

   if (layer % 2 == 0)
   {
     // octave
     x_1 = float(4 * (x_layer) - 1 - 2) / 6.0f;
     x1 = float(4 * (x_layer) - 1 + 2) / 6.0f;
     y_1 = float(4 * (y_layer) - 1 - 2) / 6.0f;
     y1 = float(4 * (y_layer) - 1 + 2) / 6.0f;
   }
   else
   {
     // intra
     x_1 = float(6 * (x_layer) - 1 - 3) / 8.0f;
     x1 = float(6 * (x_layer) - 1 + 3) / 8.0f;
     y_1 = float(6 * (y_layer) - 1 - 3) / 8.0f;
     y1 = float(6 * (y_layer) - 1 + 3) / 8.0f;
   }

   // check the first row
   int max_x = (int)x_1 + 1;
   int max_y = (int)y_1 + 1;
   float tmp_max;
   float maxval = (float)layerAbove.getAgastScore(x_1, y_1, 1);
   if (maxval > threshold)
     return 0;
   for (int x = (int)x_1 + 1; x <= int(x1); x++)
   {
     tmp_max = (float)layerAbove.getAgastScore(float(x), y_1, 1);
     if (tmp_max > threshold)
       return 0;
     if (tmp_max > maxval)
     {
       maxval = tmp_max;
       max_x = x;
     }
   }
   tmp_max = (float)layerAbove.getAgastScore(x1, y_1, 1);
   if (tmp_max > threshold)
     return 0;
   if (tmp_max > maxval)
   {
     maxval = tmp_max;
     max_x = int(x1);
   }

   // middle rows
   for (int y = (int)y_1 + 1; y <= int(y1); y++)
   {
     tmp_max = (float)layerAbove.getAgastScore(x_1, float(y), 1);
     if (tmp_max > threshold)
       return 0;
     if (tmp_max > maxval)
     {
       maxval = tmp_max;
       max_x = int(x_1 + 1);
       max_y = y;
     }
     for (int x = (int)x_1 + 1; x <= int(x1); x++)
     {
       tmp_max = (float)layerAbove.getAgastScore(x, y, 1);
       if (tmp_max > threshold)
         return 0;
       if (tmp_max > maxval)
       {
         maxval = tmp_max;
         max_x = x;
         max_y = y;
       }
     }
     tmp_max = (float)layerAbove.getAgastScore(x1, float(y), 1);
     if (tmp_max > threshold)
       return 0;
     if (tmp_max > maxval)
     {
       maxval = tmp_max;
       max_x = int(x1);
       max_y = y;
     }
   }

   // bottom row
   tmp_max = (float)layerAbove.getAgastScore(x_1, y1, 1);
   if (tmp_max > maxval)
   {
     maxval = tmp_max;
     max_x = int(x_1 + 1);
     max_y = int(y1);
   }
   for (int x = (int)x_1 + 1; x <= int(x1); x++)
   {
     tmp_max = (float)layerAbove.getAgastScore(float(x), y1, 1);
     if (tmp_max > maxval)
     {
       maxval = tmp_max;
       max_x = x;
       max_y = int(y1);
     }
   }
   tmp_max = (float)layerAbove.getAgastScore(x1, y1, 1);
   if (tmp_max > maxval)
   {
     maxval = tmp_max;
     max_x = int(x1);
     max_y = int(y1);
   }

   //find dx/dy:
   int s_0_0 = layerAbove.getAgastScore(max_x - 1, max_y - 1, 1);
   int s_1_0 = layerAbove.getAgastScore(max_x, max_y - 1, 1);
   int s_2_0 = layerAbove.getAgastScore(max_x + 1, max_y - 1, 1);
   int s_2_1 = layerAbove.getAgastScore(max_x + 1, max_y, 1);
   int s_1_1 = layerAbove.getAgastScore(max_x, max_y, 1);
   int s_0_1 = layerAbove.getAgastScore(max_x - 1, max_y, 1);
   int s_0_2 = layerAbove.getAgastScore(max_x - 1, max_y + 1, 1);
   int s_1_2 = layerAbove.getAgastScore(max_x, max_y + 1, 1);
   int s_2_2 = layerAbove.getAgastScore(max_x + 1, max_y + 1, 1);
   float dx_1, dy_1;
   float refined_max = subpixel2D(s_0_0, s_0_1, s_0_2, s_1_0, s_1_1, s_1_2, s_2_0, s_2_1, s_2_2, dx_1, dy_1);

   // calculate dx/dy in above coordinates
   float real_x = float(max_x) + dx_1;
   float real_y = float(max_y) + dy_1;
   bool returnrefined = true;
   if (layer % 2 == 0)
   {
     dx = (real_x * 6.0f + 1.0f) / 4.0f - float(x_layer);
     dy = (real_y * 6.0f + 1.0f) / 4.0f - float(y_layer);
   }
   else
   {
     dx = (real_x * 8.0f + 1.0f) / 6.0f - float(x_layer);
     dy = (real_y * 8.0f + 1.0f) / 6.0f - float(y_layer);
   }

   // saturate
   if (dx > 1.0f)
   {
     dx = 1.0f;
     returnrefined = false;
   }
   if (dx < -1.0f)
   {
     dx = -1.0f;
     returnrefined = false;
   }
   if (dy > 1.0f)
   {
     dy = 1.0f;
     returnrefined = false;
   }
   if (dy < -1.0f)
   {
     dy = -1.0f;
     returnrefined = false;
   }

   // done and ok.
   ismax = true;
   if (returnrefined)
   {
     return std::max(refined_max, maxval);
   }
   return maxval;
 }


 inline float
BriskScaleSpace1::getScoreMaxBelow(const int layer, const int x_layer, const int y_layer, const int threshold,
                                  bool& ismax, float& dx, float& dy) const
{
  ismax = false;

  // relevant floating point coordinates
  float x_1;
  float x1;
  float y_1;
  float y1;

  if (layer % 2 == 0)
  {
    // octave
    x_1 = float(8 * (x_layer) + 1 - 4) / 6.0f;
    x1 = float(8 * (x_layer) + 1 + 4) / 6.0f;
    y_1 = float(8 * (y_layer) + 1 - 4) / 6.0f;
    y1 = float(8 * (y_layer) + 1 + 4) / 6.0f;
  }
  else
  {
    x_1 = float(6 * (x_layer) + 1 - 3) / 4.0f;
    x1 = float(6 * (x_layer) + 1 + 3) / 4.0f;
    y_1 = float(6 * (y_layer) + 1 - 3) / 4.0f;
    y1 = float(6 * (y_layer) + 1 + 3) / 4.0f;
  }

  // the layer below
  CV_Assert(layer > 0);
  const BriskLayer1& layerBelow = pyramid_[layer - 1];

  // check the first row
  int max_x = (int)x_1 + 1;
  int max_y = (int)y_1 + 1;
  float tmp_max;
  float max = (float)layerBelow.getAgastScore(x_1, y_1, 1);
  if (max > threshold)
    return 0;
  for (int x = (int)x_1 + 1; x <= int(x1); x++)
  {
    tmp_max = (float)layerBelow.getAgastScore(float(x), y_1, 1);
    if (tmp_max > threshold)
      return 0;
    if (tmp_max > max)
    {
      max = tmp_max;
      max_x = x;
    }
  }
  tmp_max = (float)layerBelow.getAgastScore(x1, y_1, 1);
  if (tmp_max > threshold)
    return 0;
  if (tmp_max > max)
  {
    max = tmp_max;
    max_x = int(x1);
  }

  // middle rows
  for (int y = (int)y_1 + 1; y <= int(y1); y++)
  {
    tmp_max = (float)layerBelow.getAgastScore(x_1, float(y), 1);
    if (tmp_max > threshold)
      return 0;
    if (tmp_max > max)
    {
      max = tmp_max;
      max_x = int(x_1 + 1);
      max_y = y;
    }
    for (int x = (int)x_1 + 1; x <= int(x1); x++)
    {
      tmp_max = (float)layerBelow.getAgastScore(x, y, 1);
      if (tmp_max > threshold)
        return 0;
      if (tmp_max == max)
      {
        const int t1 = 2
            * (layerBelow.getAgastScore(x - 1, y, 1) + layerBelow.getAgastScore(x + 1, y, 1)
               + layerBelow.getAgastScore(x, y + 1, 1) + layerBelow.getAgastScore(x, y - 1, 1))
                       + (layerBelow.getAgastScore(x + 1, y + 1, 1) + layerBelow.getAgastScore(x - 1, y + 1, 1)
                          + layerBelow.getAgastScore(x + 1, y - 1, 1) + layerBelow.getAgastScore(x - 1, y - 1, 1));
        const int t2 = 2
            * (layerBelow.getAgastScore(max_x - 1, max_y, 1) + layerBelow.getAgastScore(max_x + 1, max_y, 1)
               + layerBelow.getAgastScore(max_x, max_y + 1, 1) + layerBelow.getAgastScore(max_x, max_y - 1, 1))
                       + (layerBelow.getAgastScore(max_x + 1, max_y + 1, 1) + layerBelow.getAgastScore(max_x - 1,
                                                                                                       max_y + 1, 1)
                          + layerBelow.getAgastScore(max_x + 1, max_y - 1, 1)
                          + layerBelow.getAgastScore(max_x - 1, max_y - 1, 1));
        if (t1 > t2)
        {
          max_x = x;
          max_y = y;
        }
      }
      if (tmp_max > max)
      {
        max = tmp_max;
        max_x = x;
        max_y = y;
      }
    }
    tmp_max = (float)layerBelow.getAgastScore(x1, float(y), 1);
    if (tmp_max > threshold)
      return 0;
    if (tmp_max > max)
    {
      max = tmp_max;
      max_x = int(x1);
      max_y = y;
    }
  }

  // bottom row
  tmp_max = (float)layerBelow.getAgastScore(x_1, y1, 1);
  if (tmp_max > max)
  {
    max = tmp_max;
    max_x = int(x_1 + 1);
    max_y = int(y1);
  }
  for (int x = (int)x_1 + 1; x <= int(x1); x++)
  {
    tmp_max = (float)layerBelow.getAgastScore(float(x), y1, 1);
    if (tmp_max > max)
    {
      max = tmp_max;
      max_x = x;
      max_y = int(y1);
    }
  }
  tmp_max = (float)layerBelow.getAgastScore(x1, y1, 1);
  if (tmp_max > max)
  {
    max = tmp_max;
    max_x = int(x1);
    max_y = int(y1);
  }

  //find dx/dy:
  int s_0_0 = layerBelow.getAgastScore(max_x - 1, max_y - 1, 1);
  int s_1_0 = layerBelow.getAgastScore(max_x, max_y - 1, 1);
  int s_2_0 = layerBelow.getAgastScore(max_x + 1, max_y - 1, 1);
  int s_2_1 = layerBelow.getAgastScore(max_x + 1, max_y, 1);
  int s_1_1 = layerBelow.getAgastScore(max_x, max_y, 1);
  int s_0_1 = layerBelow.getAgastScore(max_x - 1, max_y, 1);
  int s_0_2 = layerBelow.getAgastScore(max_x - 1, max_y + 1, 1);
  int s_1_2 = layerBelow.getAgastScore(max_x, max_y + 1, 1);
  int s_2_2 = layerBelow.getAgastScore(max_x + 1, max_y + 1, 1);
  float dx_1, dy_1;
  float refined_max = subpixel2D(s_0_0, s_0_1, s_0_2, s_1_0, s_1_1, s_1_2, s_2_0, s_2_1, s_2_2, dx_1, dy_1);

  // calculate dx/dy in above coordinates
  float real_x = float(max_x) + dx_1;
  float real_y = float(max_y) + dy_1;
  bool returnrefined = true;
  if (layer % 2 == 0)
  {
    dx = (float)((real_x * 6.0 + 1.0) / 8.0) - float(x_layer);
    dy = (float)((real_y * 6.0 + 1.0) / 8.0) - float(y_layer);
  }
  else
  {
    dx = (float)((real_x * 4.0 - 1.0) / 6.0) - float(x_layer);
    dy = (float)((real_y * 4.0 - 1.0) / 6.0) - float(y_layer);
  }

  // saturate
  if (dx > 1.0)
  {
    dx = 1.0f;
    returnrefined = false;
  }
  if (dx < -1.0f)
  {
    dx = -1.0f;
    returnrefined = false;
  }
  if (dy > 1.0f)
  {
    dy = 1.0f;
    returnrefined = false;
  }
  if (dy < -1.0f)
  {
    dy = -1.0f;
    returnrefined = false;
  }

  // done and ok.
  ismax = true;
  if (returnrefined)
  {
    return std::max(refined_max, max);
  }
  return max;

}








// construct a layer
BriskLayer1::BriskLayer1(const cv::Mat& img_in, float scale_in, float offset_in)
{
  img_ = img_in;
  scores_ = cv::Mat_<uchar>::zeros(img_in.rows, img_in.cols);
  // attention: this means that the passed image reference must point to persistent memory
  scale_ = scale_in;
  offset_ = offset_in;
  // create an agast detector
  oast_9_16_ = AgastFeatureDetector::create(1, false, AgastFeatureDetector::OAST_9_16);
  makeAgastOffsets1(pixel_5_8_, (int)img_.step);
  makeAgastOffsets2(pixel_9_16_, (int)img_.step);
}


BriskLayer1::BriskLayer1(const BriskLayer1& layer, int mode)
{
  if (mode == CommonParams::HALFSAMPLE)
  {
    img_.create(layer.img().rows / 2, layer.img().cols / 2, CV_8U);
    halfsample(layer.img(), img_);
    scale_ = layer.scale() * 2;
    offset_ = 0.5f * scale_ - 0.5f;
  }

  else
  {
    img_.create(2 * (layer.img().rows / 3), 2 * (layer.img().cols / 3), CV_8U);
    twothirdsample(layer.img(), img_);
    scale_ = layer.scale() * 1.5f;
    offset_ = 0.5f * scale_ - 0.5f;
  }
 scores_ = cv::Mat::zeros(img_.rows, img_.cols, CV_8U);
  oast_9_16_ = AgastFeatureDetector::create(1, false, AgastFeatureDetector::OAST_9_16);
  makeAgastOffsets1(pixel_5_8_, (int)img_.step);
  makeAgastOffsets2(pixel_9_16_, (int)img_.step);
}




void
BriskLayer1::getAgastPoints(int threshold, std::vector<KeyPoint>& keypoints)
{ //cout<<threshold;
  oast_9_16_->setThreshold(threshold);
  oast_9_16_->detect(img_, keypoints);
  //cv::AGAST (img_,keypoints,10,true);
  //cout<<"AGASTPOINTS GETTING\n"<<keypoints.size();
  // also write scores
  const size_t num = keypoints.size();
  cout<<"num"<<num<<"\n";
  for (size_t i = 0; i < num; i++)
    scores_((int)keypoints[i].pt.y, (int)keypoints[i].pt.x) = cv::saturate_cast<uchar>(keypoints[i].response);
}

inline int
BriskLayer1::getAgastScore(int x, int y, int threshold) const
{
  if (x < 3 || y < 3)
    return 0;
  if (x >= img_.cols - 3 || y >= img_.rows - 3)
    return 0;
  uchar& score = (uchar&)scores_(y, x);
  if (score > 2)
  {
    return score;
  }
  score = (uchar) agast_cornerScore11(&img_.at<uchar>(y, x), pixel_9_16_, threshold - 1);
  //cout<<"Score"<<score<<"\n";
  if (score < threshold)
    score = 0;
  return score;
}

inline int
BriskLayer1::getAgastScore_5_8(int x, int y, int threshold) const
{
  if (x < 2 || y < 2)
    return 0;
  if (x >= img_.cols - 2 || y >= img_.rows - 2)
    return 0;
  int score = agast_cornerScore12(&img_.at<uchar>(y, x), pixel_5_8_, threshold - 1);
  //cout<<"Score2"<<score<<"\n";
  if (score < threshold)
    score = 0;
  return score;
}


inline int
BriskLayer1::getAgastScore(float xf, float yf, int threshold_in, float scale_in) const
{
  if (scale_in <= 1.0f)
  {
    // just do an interpolation inside the layer
    const int x = int(xf);
    const float rx1 = xf - float(x);
    const float rx = 1.0f - rx1;
    const int y = int(yf);
    const float ry1 = yf - float(y);
    const float ry = 1.0f - ry1;

    return (uchar)(rx * ry * getAgastScore(x, y, threshold_in) + rx1 * ry * getAgastScore(x + 1, y, threshold_in)
           + rx * ry1 * getAgastScore(x, y + 1, threshold_in) + rx1 * ry1 * getAgastScore(x + 1, y + 1, threshold_in));
  }
  else
  {
    // this means we overlap area smoothing
    const float halfscale = scale_in / 2.0f;
    // get the scores first:
    for (int x = int(xf - halfscale); x <= int(xf + halfscale + 1.0f); x++)
    {
      for (int y = int(yf - halfscale); y <= int(yf + halfscale + 1.0f); y++)
      {
        getAgastScore(x, y, threshold_in);
      }
    }
    // get the smoothed value
    return value(scores_, xf, yf, scale_in);
  }
}


// access gray values (smoothed/interpolated)
inline int
BriskLayer1::value(const cv::Mat& mat, float xf, float yf, float scale_in) const
{
  CV_Assert(!mat.empty());
  // get the position
  const int x = cvFloor(xf);
  const int y = cvFloor(yf);
  const cv::Mat& image = mat;
  const int& imagecols = image.cols;

  // get the sigma_half:
  const float sigma_half = scale_in / 2;
  const float area = 4.0f * sigma_half * sigma_half;
  // calculate output:
  int ret_val;
  if (sigma_half < 0.5)
  {
    //interpolation multipliers:
    const int r_x = (int)((xf - x) * 1024);
    const int r_y = (int)((yf - y) * 1024);
    const int r_x_1 = (1024 - r_x);
    const int r_y_1 = (1024 - r_y);
    const uchar* ptr = image.ptr() + x + y * imagecols;
    // just interpolate:
    ret_val = (r_x_1 * r_y_1 * int(*ptr));
    ptr++;
    ret_val += (r_x * r_y_1 * int(*ptr));
    ptr += imagecols;
    ret_val += (r_x * r_y * int(*ptr));
    ptr--;
    ret_val += (r_x_1 * r_y * int(*ptr));
    return 0xFF & ((ret_val + 512) / 1024 / 1024);
  }



  // this is the standard case (simple, not speed optimized yet):

  // scaling:
  const int scaling = (int)(4194304.0f / area);
  const int scaling2 = (int)(float(scaling) * area / 1024.0f);
  CV_Assert(scaling2 != 0);

  // calculate borders
  const float x_1 = xf - sigma_half;
  const float x1 = xf + sigma_half;
  const float y_1 = yf - sigma_half;
  const float y1 = yf + sigma_half;

  const int x_left = int(x_1 + 0.5);
  const int y_top = int(y_1 + 0.5);
  const int x_right = int(x1 + 0.5);
  const int y_bottom = int(y1 + 0.5);

  // overlap area - multiplication factors:
  const float r_x_1 = float(x_left) - x_1 + 0.5f;
  const float r_y_1 = float(y_top) - y_1 + 0.5f;
  const float r_x1 = x1 - float(x_right) + 0.5f;
  const float r_y1 = y1 - float(y_bottom) + 0.5f;
  const int dx = x_right - x_left - 1;
  const int dy = y_bottom - y_top - 1;
  const int A = (int)((r_x_1 * r_y_1) * scaling);
  const int B = (int)((r_x1 * r_y_1) * scaling);
  const int C = (int)((r_x1 * r_y1) * scaling);
  const int D = (int)((r_x_1 * r_y1) * scaling);
  const int r_x_1_i = (int)(r_x_1 * scaling);
  const int r_y_1_i = (int)(r_y_1 * scaling);
  const int r_x1_i = (int)(r_x1 * scaling);
  const int r_y1_i = (int)(r_y1 * scaling);

  // now the calculation:
  const uchar* ptr = image.ptr() + x_left + imagecols * y_top;
  // first row:
  ret_val = A * int(*ptr);
  ptr++;
  const uchar* end1 = ptr + dx;
  for (; ptr < end1; ptr++)
  {
    ret_val += r_y_1_i * int(*ptr);
  }
  ret_val += B * int(*ptr);
  // middle ones:
  ptr += imagecols - dx - 1;
  const uchar* end_j = ptr + dy * imagecols;
  for (; ptr < end_j; ptr += imagecols - dx - 1)
  {
    ret_val += r_x_1_i * int(*ptr);
    ptr++;
    const uchar* end2 = ptr + dx;
    for (; ptr < end2; ptr++)
    {
      ret_val += int(*ptr) * scaling;
    }
    ret_val += r_x1_i * int(*ptr);
  }
  // last row:
  ret_val += D * int(*ptr);
  ptr++;
  const uchar* end3 = ptr + dx;
  for (; ptr < end3; ptr++)
  {
    ret_val += r_y1_i * int(*ptr);
  }
  ret_val += C * int(*ptr);

  return 0xFF & ((ret_val + scaling2 / 2) / scaling2 / 1024);
}


inline void
BriskLayer1::halfsample(const cv::Mat& srcimg, cv::Mat& dstimg)
{
  // make sure the destination image is of the right size:
  CV_Assert(srcimg.cols / 2 == dstimg.cols);
  CV_Assert(srcimg.rows / 2 == dstimg.rows);

  // handle non-SSE case
  resize(srcimg, dstimg, dstimg.size(), 0, 0, cv::INTER_AREA);
}

inline void
BriskLayer1::twothirdsample(const Mat& srcimg, cv::Mat& dstimg)
{
  // make sure the destination image is of the right size:
  CV_Assert((srcimg.cols / 3) * 2 == dstimg.cols);
  CV_Assert((srcimg.rows / 3) * 2 == dstimg.rows);

  resize(srcimg, dstimg, dstimg.size(), 0, 0, cv::INTER_AREA);
}

const double kDistanceCoef = 4.0;
const int kMaxMatchingSize = 50;
inline void match( Mat& desc1, Mat& desc2, vector<DMatch>& matches) {
    matches.clear();

        BFMatcher desc_matcher(cv::NORM_L2, true);
        vector< vector<DMatch> > vmatches;
        desc_matcher.knnMatch(desc1, desc2, vmatches, 1);
        for (int i = 0; i < static_cast<int>(vmatches.size()); ++i) {
            if (!vmatches[i].size()) {
                continue;
            }
            matches.push_back(vmatches[i][0]);
        }

    std::sort(matches.begin(), matches.end());
    while (matches.front().distance * kDistanceCoef < matches.back().distance) {
        matches.pop_back();
    }
    while (matches.size() > kMaxMatchingSize) {
        matches.pop_back();
    }
}

inline void findKeyPointsHomography(vector<KeyPoint>& kpts1, vector<KeyPoint>& kpts2,
        vector<DMatch>& matches, vector<char>& match_mask) {
    if (static_cast<int>(match_mask.size()) < 3) {
        return;
    }
    vector<Point2f> pts1;
    vector<Point2f> pts2;
    for (int i = 0; i < static_cast<int>(matches.size()); ++i) {
        pts1.push_back(kpts1[matches[i].queryIdx].pt);
        pts2.push_back(kpts2[matches[i].trainIdx].pt);
    }
    findHomography(pts1, pts2, cv::RANSAC, 4, match_mask);
}



int main(int argc, char** argv) {
  /* MPI_Init(NULL,NULL);
    int rank,size;
   MPI_Comm_size(MPI_COMM_WORLD,&size);
   MPI_Comm_rank(MPI_COMM_WORLD,&rank);
  */
   int n=4;

    Mat img1 = cv::imread("Img1.jpg", CV_LOAD_IMAGE_COLOR);
    resize(img1, img1, cv::Size(img1.cols/4, img1.rows/4));

    if (img1.channels() != 1) {
        cvtColor(img1, img1, cv::COLOR_RGB2GRAY);
    }
      vector<KeyPoint> kpts1;
      Mat desc1;
      BRISK_Impl1 a1=BRISK_Impl1(20,1,1.0);
      a1.detectAndCompute(img1, Mat(), kpts1, desc1,1);

     if(1)
      {int max=0;
      string Final_img;
           for(char i=0;i<n/2;i++)
             {
               string img_name=".jpg";
              //  img_name=img_name+".jpg";
          //     img_name=img_name+".png";
          //     //char img_name[20]="image";
          //     //char *ii;
            cout<<i+img_name;
              //cout<<"Img_name\n"<<img_name;
                Mat img = cv::imread("0.jpg", CV_LOAD_IMAGE_COLOR);
                //resize(img, img, cv::Size(img1.cols/4, img1.rows/4));

                if (img.channels() != 1) {
                    cvtColor(img, img, cv::COLOR_RGB2GRAY);
              }
            vector<KeyPoint> kpts;
            Mat desc;
            BRISK_Impl1 a2=BRISK_Impl1(20,1,1.0);
            a2.detectAndCompute(img, Mat(), kpts, desc,1);
              vector<DMatch> matches;

            match(desc1, desc, matches);
           
            if(matches.size()>max)
                {
                  max=matches.size();
                 Final_img=i+img_name;
                }
            vector<char> match_mask(matches.size(), 1);
            findKeyPointsHomography(kpts1, kpts, matches, match_mask);
            //cout<<desc.size();
            Mat res;
            cv::drawMatches(img1, kpts1, img, kpts, matches, res, Scalar::all(-1),
                Scalar::all(-1), match_mask, DrawMatchesFlags::NOT_DRAW_SINGLE_POINTS);
              cout<<"\n"<<"MATCHES"<<matches.size()<<"\n";
            cv::imshow("result", res);
            cv::waitKey(0);

          }
          cout<<Final_img;
     }
     //else
     {
       for(int i=n/2;i<n;i++)
         {
            // char img_name[20]="image";
            // strcat(img_name,i);
            // strcat(img_name,".png");
              Mat img = cv::imread("pdp.jpg", CV_LOAD_IMAGE_COLOR);
             //resize(img, img, cv::Size(img.cols/4, img.rows/4));
             cout<<"hey";
             if (img.channels() != 1) {
                 cvtColor(img, img, cv::COLOR_RGB2GRAY);
           }
         vector<KeyPoint> kpts;
         Mat desc;
         BRISK_Impl1 a2=BRISK_Impl1(20,1,1.0);
         a2.detectAndCompute(img, Mat(), kpts, desc,1);

         vector<DMatch> matches;

         match(desc1, desc, matches);
         cout<<"\nMatches"<<matches.size()<<"\n";
         vector<char> match_mask(matches.size(), 1);
         findKeyPointsHomography(kpts1, kpts, matches, match_mask);
         //cout<<desc.size();
         Mat res;
         cv::drawMatches(img1, kpts1, img, kpts, matches, res, Scalar::all(-1),
             Scalar::all(-1), match_mask, DrawMatchesFlags::NOT_DRAW_SINGLE_POINTS);

         cv::imshow("result", res);
         cv::waitKey(0);
       }
    }
//MPI_Finalize();
    return 0;
}


 
A V S KASTURI KARTHIK 16BCE1225 <av.skasturikarthik2016@vitstudent.ac.in>
 
(no subject)
 
kausthubha CH <kausthubha99@gmail.com>	Tue, Nov 13, 2018 at 4:55 AM
To: A V S KASTURI KARTHIK 16BCE1225 <av.skasturikarthik2016@vitstudent.ac.in>
//#include "precomp.hpp"
#include <fstream>
#include <stdlib.h>
#include<cv.h>
#include<omp.h>
#include <opencv2/features2d.hpp>
//#include <opencv2/features2d/src/agast_score.hpps >
#include <vector>
#include <iostream>
#include <cstdlib>
#include <fstream>
#include <opencv2/opencv.hpp>
#include <opencv2/core.hpp>
//#include<mpi.h>
#include "pre.hpp"
#include "Agast.hpp"
//#include<open
using namespace std;
// using std::cout;
// using std::cerr;
// using std::vector;
// using std::string;

//using cv::
using namespace cv;
using namespace abb ;



// using cv::AGAST;
// using cv::AgastFeatureDetector;
// using cv::Mat;
// using cv::Point2f;
// using cv::KeyPoint;
// using cv::Scalar;
// using cv::Ptr;
// using cv::BRISK;
// using cv::AGAST;
// using cv::makePtr;
// using cv::InputArray;
// using cv::OutputArray;
// //using cv::_OVERRIDE;
//

//using cv::AGASTScore;


class BRISK_Impl1:public BRISK
{
public:

    explicit BRISK_Impl1(int thresh=30, int octaves=3, float patternScale=1.0f);

    //virtual ~BRISK_Impl1();

 void generateKernel1(const std::vector<float> &radiusList,
        const std::vector<int> &numberList, float dMax=5.85f, float dMin=8.2f,
        const std::vector<int> &indexChange=std::vector<int>());

 void detectAndCompute( InputArray image, InputArray mask,
                     CV_OUT std::vector<KeyPoint>& keypoints,
                     OutputArray descriptors,
                     bool useProvidedKeypoints ) ;//CV_OVERRIDE;


                   protected:
    void computeKeypointsNoOrientation(InputArray image, InputArray mask, std::vector<KeyPoint>& keypoints) const;
    void computeDescriptorsAndOrOrientation(InputArray image, InputArray mask, std::vector<KeyPoint>& keypoints,
                                       OutputArray descriptors, bool doDescriptors, bool doOrientation,
                                       bool useProvidedKeypoints) const;
    CV_PROP_RW int threshold;
    CV_PROP_RW int octaves;

     struct BriskPatternPoint{
        float x;         // x coordinate relative to center
        float y;         // x coordinate relative to center
        float sigma;     // Gaussian smoothing sigma
    };
    struct BriskShortPair{
        unsigned int i;  // index of the first pattern point
        unsigned int j;  // index of other pattern point
    };
    struct BriskLongPair{
        unsigned int i;  // index of the first pattern point
        unsigned int j;  // index of other pattern point
        int weighted_dx; // 1024.0/dx
        int weighted_dy; // 1024.0/dy
    };

    inline int smoothedIntensity(const cv::Mat& image,
                const cv::Mat& integral,const float key_x,
                const float key_y, const unsigned int scale,
                const unsigned int rot, const unsigned int point) const;


    BriskPatternPoint* patternPoints_;     //[i][rotation][scale]
    unsigned int points_;                 // total number of collocation points
    float* scaleList_;                     // lists the scaling per scale index [scale]
    unsigned int* sizeList_;             // lists the total pattern size per scale index [scale]
    static const unsigned int scales_;    // scales discretization
    static const float scalerange_;     // span of sizes 40->4 Octaves - else, this needs to be adjusted...
    static const unsigned int n_rot_;    // discretization of the rotation look-up

    // pairs
    int strings_;                        // number of uchars the descriptor consists of
    float dMax_;                         // short pair maximum distance
    float dMin_;                         // long pair maximum distance
    BriskShortPair* shortPairs_;         // d<_dMax
    BriskLongPair* longPairs_;             // d>_dMin
    unsigned int noShortPairs_;         // number of shortParis
    unsigned int noLongPairs_;             // number of longParis

    // general
    static const float basicSize_;



private:
  //  BRISK_Impl1(const BRISK_Impl1 &); // copy disabled
    //BRISK_Impl1& operator=(const BRISK_Impl1 &); // assign disabled


  };

  class BriskLayer1
  {
  public:
      struct CommonParams
    {
      static const int HALFSAMPLE = 0;
      static const int TWOTHIRDSAMPLE = 1;
    };

      // construct a base layer
    BriskLayer1(const cv::Mat& img, float scale = 1.0f, float offset = 0.0f);
    // derive a layer
    BriskLayer1(const BriskLayer1& layer, int mode);


    // Agast without non-max suppression
    void
    getAgastPoints(int threshold, std::vector<cv::KeyPoint>& keypoints);

    // get scores - attention, this is in layer coordinates, not scale=1 coordinates!
    inline int
    getAgastScore(int x, int y, int threshold) const;
    inline int
    getAgastScore_5_8(int x, int y, int threshold) const ;

    inline int
    getAgastScore(float xf, float yf, int threshold, float scale = 1.0f) const;

    // accessors
    inline const cv::Mat&
    img() const
    {
      return img_;
    }
    inline const cv::Mat&
    scores() const
    {
      return scores_;
    }
    inline float
    scale() const
    {
      return scale_;
    }
    inline float
    offset() const
    {
      return offset_;
    }

    // half sampling
    static inline void
    halfsample(const cv::Mat& srcimg, cv::Mat& dstimg);
    // two third sampling
    static inline void
    twothirdsample(const cv::Mat& srcimg, cv::Mat& dstimg);

  private:
    // access gray values (smoothed/interpolated)
    inline int
    value(const cv::Mat& mat, float xf, float yf, float scale) const;
    // the image
    cv::Mat img_;
    // its Agast scores
    cv::Mat_<uchar> scores_;
    // coordinate transformation
    float scale_;
    float offset_;
    // agast
    cv::Ptr<cv::AgastFeatureDetector> oast_9_16_;
    int pixel_5_8_[25];
    int pixel_9_16_[25];
  };


class BriskScaleSpace1
{
public:
   //construct telling the octaves number:
  BriskScaleSpace1(int _octaves = 3);
  ~BriskScaleSpace1();

 // construct the image pyramids
  void
  constructPyramid(const cv::Mat& image);

  // get Keypoints
  void
  getKeypoints(const int _threshold, std::vector<cv::KeyPoint>& keypoints);

protected:
  // nonmax suppression:
  inline bool
  isMax2D(const int layer, const int x_layer, const int y_layer);


inline float
  refine1D(const float s_05, const float s0, const float s05, float& max) const; // around octave
  inline float
  refine1D_1(const float s_05, const float s0, const float s05, float& max) const; // around intra
  inline float
  refine1D_2(const float s_05, const float s0, const float s05, float& max) const; // around octave 0 only
  // 2D maximum refinement:
  inline float
  subpixel2D(const int s_0_0, const int s_0_1, const int s_0_2, const int s_1_0, const int s_1_1, const int s_1_2,
             const int s_2_0, const int s_2_1, const int s_2_2, float& delta_x, float& delta_y) const;
  // 3D maximum refinement centered around (x_layer,y_layer)
  inline float
  refine3D(const int layer, const int x_layer, const int y_layer, float& x, float& y, float& scale, bool& ismax) const;


  inline float
  getScoreMaxAbove(const int layer, const int x_layer, const int y_layer, const int threshold, bool& ismax,
                   float& dx, float& dy) const;
  inline float
  getScoreMaxBelow(const int layer, const int x_layer, const int y_layer, const int threshold, bool& ismax,
                   float& dx, float& dy) const;


 // the image pyramids:
  int layers_;
  std::vector<BriskLayer1> pyramid_;

  // some constant parameters:
  static const float safetyFactor_;
  static const float basicSize_;
};







const float BRISK_Impl1::basicSize_ = 12.0f;
const unsigned int BRISK_Impl1::scales_ = 64;
const float BRISK_Impl1::scalerange_ = 30.f; // 40->4 Octaves - else, this needs to be adjusted...
const unsigned int BRISK_Impl1::n_rot_ = 1024; // discretization of the rotation look-up
const float BriskScaleSpace1::safetyFactor_ = 1.0f;
const float BriskScaleSpace1::basicSize_ = 12.0f;

BRISK_Impl1::BRISK_Impl1(int thresh, int octaves_in, float patternScale)
{
     threshold = thresh;
  octaves = octaves_in;

  std::vector<float> rList;
  std::vector<int> nList;

  // this is the standard pattern found to be suitable also
  rList.resize(5);
  nList.resize(5);
  const double f = 0.85 * patternScale;

  rList[0] = (float)(f * 0.);
  rList[1] = (float)(f * 2.9);
  rList[2] = (float)(f * 4.9);
  rList[3] = (float)(f * 7.4);
  rList[4] = (float)(f * 10.8);

  nList[0] = 1;
  nList[1] = 10;
  nList[2] = 14;
  nList[3] = 15;
  nList[4] = 20;

  generateKernel1(rList, nList, (float)(5.85 * patternScale), (float)(8.2 * patternScale));
}

void BRISK_Impl1::generateKernel1(const std::vector<float> &radiusList,
                           const std::vector<int> &numberList,
                           float dMax, float dMin,
                           const std::vector<int>& _indexChange)
{
    std::vector<int> indexChange = _indexChange;
  dMax_ = dMax;
  dMin_ = dMin;

  // get the total number of points
  const int rings = (int)radiusList.size();
  CV_Assert(radiusList.size() != 0 && radiusList.size() == numberList.size());
  points_ = 0; // remember the total number of points
  for (int ring = 0; ring < rings; ring++)
  {
    points_ += numberList[ring];                                                        //CAN USE REDUCE OPENMP
  }

  patternPoints_ = new BriskPatternPoint[points_ * scales_ * n_rot_];
  BriskPatternPoint* patternIterator = patternPoints_;               //A struct

  static const float lb_scale = (float)(std::log(scalerange_) / std::log(2.0));
  static const float lb_scale_step = lb_scale / (scales_);

  scaleList_ = new float[scales_];
  sizeList_ = new unsigned int[scales_];

   const float sigma_scale = 1.3f;

   for (unsigned int scale = 0; scale < scales_; ++scale)
    {
            scaleList_[scale] = (float)std::pow((double) 2.0, (double) (scale * lb_scale_step));
            sizeList_[scale] = 0;
            // generate the pattern points look-up
            double alpha, theta;
            for (size_t rot = 0; rot < n_rot_; ++rot)
            {
              theta = double(rot) * 2 * CV_PI / double(n_rot_); // this is the rotation of the feature
              for (int ring = 0; ring < rings; ++ring)
              {
                for (int num = 0; num < numberList[ring]; ++num)
                {
                  // the actual coordinates on the circle
                  alpha = (double(num)) * 2 * CV_PI / double(numberList[ring]);
                  patternIterator->x = (float)(scaleList_[scale] * radiusList[ring] * cos(alpha + theta)); // feature rotation plus angle of the point
                  patternIterator->y = (float)(scaleList_[scale] * radiusList[ring] * sin(alpha + theta));
                  // and the gaussian kernel sigma
                  if (ring == 0)
                  {
                    patternIterator->sigma = sigma_scale * scaleList_[scale] * 0.5f;
                  }
                  else
                  {
                    patternIterator->sigma = (float)(sigma_scale * scaleList_[scale] * (double(radiusList[ring]))
                                             * sin(CV_PI / numberList[ring]));
                  }
                  // adapt the sizeList if necessary
                  const unsigned int size = cvCeil(((scaleList_[scale] * radiusList[ring]) + patternIterator->sigma)) + 1;
                  if (sizeList_[scale] < size)
                  {
                    sizeList_[scale] = size;
                  }

                  // increment the iterator
                  ++patternIterator;
                }
              }
            }
    }

  // now also generate pairings
  shortPairs_ = new BriskShortPair[points_ * (points_ - 1) / 2];
  longPairs_ = new BriskLongPair[points_ * (points_ - 1) / 2];
  noShortPairs_ = 0;
  noLongPairs_ = 0;

    unsigned int indSize = (unsigned int)indexChange.size();
    if (indSize == 0)
      {
        indexChange.resize(points_ * (points_ - 1) / 2);
        indSize = (unsigned int)indexChange.size();

        for (unsigned int i = 0; i < indSize; i++)
          indexChange[i] = i;
      }

 const float dMin_sq = dMin_ * dMin_;
 const float dMax_sq = dMax_ * dMax_;


 for (unsigned int i = 1; i < points_; i++)
  {
    for (unsigned int j = 0; j < i; j++)
    { //(find all the pairs)
      // point pair distance:
      const float dx = patternPoints_[j].x - patternPoints_[i].x;
      const float dy = patternPoints_[j].y - patternPoints_[i].y;
      const float norm_sq = (dx * dx + dy * dy);

      if (norm_sq > dMin_sq)
      {
        // save to long pairs
        BriskLongPair& longPair = longPairs_[noLongPairs_];
        longPair.weighted_dx = int((dx / (norm_sq)) * 2048.0 + 0.5);
        longPair.weighted_dy = int((dy / (norm_sq)) * 2048.0 + 0.5);
        longPair.i = i;
        longPair.j = j;
        ++noLongPairs_;
      }

else if (norm_sq < dMax_sq)
      {
        // save to short pairs
        CV_Assert(noShortPairs_ < indSize);
        // make sure the user passes something sensible
        BriskShortPair& shortPair = shortPairs_[indexChange[noShortPairs_]];
        shortPair.j = j;
        shortPair.i = i;
        ++noShortPairs_;
      }
    }
  }
  // no bits:
  strings_ = (int) ceil((float(noShortPairs_)) / 128.0) * 4 * 4;


}

void
BRISK_Impl1::detectAndCompute( InputArray _image, InputArray _mask, std::vector<KeyPoint>& keypoints,
                              OutputArray _descriptors, bool useProvidedKeypoints)
{//cout<<"Detect and compute"<<octaves;
  bool doOrientation=true;

  // If the user specified cv::noArray(), this will yield false. Otherwise it will return true.
  bool doDescriptors = _descriptors.needed();

  computeDescriptorsAndOrOrientation(_image, _mask, keypoints, _descriptors, doDescriptors, doOrientation,
                                       useProvidedKeypoints);
}
inline bool
RoiPredicate(const float minX, const float minY, const float maxX, const float maxY, const KeyPoint& keyPt)
{
  const Point2f& pt = keyPt.pt;
  return (pt.x < minX) || (pt.x >= maxX) || (pt.y < minY) || (pt.y >= maxY);
}

void
BRISK_Impl1::computeDescriptorsAndOrOrientation(InputArray _image, InputArray _mask, std::vector<KeyPoint>& keypoints,
                                     OutputArray _descriptors, bool doDescriptors, bool doOrientation,
                                     bool useProvidedKeypoints) const
{
  Mat image = _image.getMat(), mask = _mask.getMat();
  if( image.type() != CV_8UC1 )
      cvtColor(image, image, cv::COLOR_BGR2GRAY);

    // if (!useProvidedKeypoints)
    //   cout<<"JEA";
    // //{


     doOrientation = true;
     computeKeypointsNoOrientation(_image, _mask, keypoints);
  // }

   //Remove keypoints very close to the border
  size_t ksize = keypoints.size();
  //cout<<"Keypoints :"<<keypoints.size();
  std::vector<int> kscales; // remember the scale per keypoint
  kscales.resize(ksize);
  static const float log2 = 0.693147180559945f;
  static const float lb_scalerange = (float)(std::log(scalerange_) / (log2));
  std::vector<cv::KeyPoint>::iterator beginning = keypoints.begin();
  std::vector<int>::iterator beginningkscales = kscales.begin();
  static const float basicSize06 = basicSize_ * 0.6f;

//  #pragma omp parallel for
   for (size_t k = 0; k < ksize; k++)
  {
    unsigned int scale;
      scale = std::max((int) (scales_ / lb_scalerange * (std::log(keypoints[k].size / (basicSize06)) / log2) + 0.5), 0);
      // saturate
      if (scale >= scales_)
        scale = scales_ - 1;
      kscales[k] = scale;

    const int border = sizeList_[scale];
    const int border_x = image.cols - border;
    const int border_y = image.rows - border;

    if (RoiPredicate((float)border, (float)border, (float)border_x, (float)border_y, keypoints[k]))
    {

      keypoints.erase(beginning + k);
      kscales.erase(beginningkscales + k);
      if (k == 0)
      {
        beginning = keypoints.begin();
        beginningkscales = kscales.begin();
      }
      ksize--;
      k--;
    }
  }

// first, calculate the integral image over the whole image:
  // current integral image
  cv::Mat _integral; // the integral image
  cv::integral(image, _integral);

  int* _values = new int[points_]; // for temporary use

  // resize the descriptors:
  cv::Mat descriptors;
  if (doDescriptors)
  {
    _descriptors.create((int)ksize, strings_, CV_8U);
    descriptors = _descriptors.getMat();
    descriptors.setTo(0);
  }

 // now do the extraction for all keypoints:

  // temporary variables containing gray values at sample points:
  int t1;
  int t2;
//cout<<"\nmmm"<<ksize;
  // the feature orientation
    const uchar* ptr = descriptors.ptr();
  for (size_t k = 0; k < ksize; k++)
  {
    cv::KeyPoint& kp = keypoints[k];
    const int& scale = kscales[k];
    const float& x = kp.pt.x;
    const float& y = kp.pt.y;
  //  cout<<"ComputeDescribe\n" ;
    if (doOrientation)
    {
        // get the gray values in the unrotated pattern
        #pragma omp prallel for
        for (unsigned int i = 0; i < points_; i++)
        {
            _values[i] = smoothedIntensity(image, _integral, x, y, scale, 0, i);
        }
        int direction0=0;
        int direction1=0;

         // now iterate through the long pairings
        const BriskLongPair* max = longPairs_ + noLongPairs_;
        for (BriskLongPair* iter = longPairs_; iter < max; ++iter)
        {
            CV_Assert(iter->i < points_ && iter->j < points_);
          t1 = *(_values + iter->i);
          t2 = *(_values + iter->j);

          const int delta_t = (t1 - t2);
          // update the direction:
          const int tmp0 = delta_t * (iter->weighted_dx) / 1024;                            //parlalize
          const int tmp1 = delta_t * (iter->weighted_dy) / 1024;
          direction0 += tmp0;
          direction1 += tmp1;
        }        kp.angle = (float)(atan2((float) direction1, (float) direction0) / CV_PI * 180.0);

        if (!doDescriptors)
        {
          if (kp.angle < 0)
            kp.angle += 360.f;
        }
    }

    if (!doDescriptors)
      continue;

     int theta;
    if (kp.angle==-1)
    {
         // don't compute the gradient direction, just assign a rotation of 0
        theta = 0;
    }
    else
    {
         theta = (int) (n_rot_ * (kp.angle / (360.0)) + 0.5);
        if (theta < 0)
          theta += n_rot_;
        if (theta >= int(n_rot_))
          theta -= n_rot_;
    }

    if(kp.angle<0)
        kp.angle+=360.f;
    // now also extract the stuff for the actual direction:
    // let us compute the smoothed values
    int shifter = 0;
    //unsigned int mean=0;
    // get the gray values in the rotated pattern
    #pragma omp parallel for
    for (unsigned int i = 0; i < points_; i++)
    {
        _values[i] = smoothedIntensity(image, _integral, x, y, scale, theta, i);
    }


    // now iterate through all the short pairings
    unsigned int* ptr2 = (unsigned int*) ptr;

    const BriskShortPair* max = shortPairs_ + noShortPairs_;
    for (BriskShortPair* iter = shortPairs_; iter < max; ++iter)
    {
        CV_Assert(iter->i < points_ && iter->j < points_);
      t1 = *(_values + iter->i);
      t2 = *(_values + iter->j);
      if (t1 > t2)
      {
        *ptr2 |= ((1) << shifter);

      } // else already initialized with zero
      // take care of the iterators:
       ++shifter;
      if (shifter == 32)
      {
        shifter = 0;
        ++ptr2;
      }
      //cout<<"PTR"<<ptr2;

    }
ptr+=strings_;

}

 // clean-up
  delete[] _values;
}

void
BRISK_Impl1::computeKeypointsNoOrientation(InputArray _image, InputArray _mask, std::vector<KeyPoint>& keypoints) const
{
  //cout<<"JERERAF";
  Mat image = _image.getMat(), mask = _mask.getMat();
  if( image.type() != CV_8UC1 )
      cvtColor(_image, image, cv::COLOR_BGR2GRAY);
  BriskScaleSpace1 BriskScaleSpace1(octaves);
  BriskScaleSpace1.constructPyramid(image);
  BriskScaleSpace1.getKeypoints(threshold, keypoints);

  // remove invalid points
  //cv::KeyPointsFilter::runByPixelsMask(keypoints, mask);
}


inline int
BRISK_Impl1::smoothedIntensity(const cv::Mat& image, const cv::Mat& integral, const float key_x,
                                            const float key_y, const unsigned int scale, const unsigned int rot,
                                            const unsigned int point) const
{
     // get the float position
  const BriskPatternPoint& briskPoint = patternPoints_[scale * n_rot_ * points_ + rot * points_ + point];
  const float xf = briskPoint.x + key_x;
  const float yf = briskPoint.y + key_y;
  const int x = int(xf);
  const int y = int(yf);
  const int& imagecols = image.cols;


  // get the sigma:
  const float sigma_half = briskPoint.sigma;
  const float area = 4.0f * sigma_half * sigma_half;

  // calculate output:
  int ret_val;
  if (sigma_half < 0.5)
  {
    //interpolation multipliers:
    const int r_x = (int)((xf - x) * 1024);
    const int r_y = (int)((yf - y) * 1024);
    const int r_x_1 = (1024 - r_x);
    const int r_y_1 = (1024 - r_y);
    const uchar* ptr = &image.at<uchar>(y, x);
    size_t step = image.step;
    // just interpolate:
    ret_val = r_x_1 * r_y_1 * ptr[0] + r_x * r_y_1 * ptr[1] +
              r_x * r_y * ptr[step] + r_x_1 * r_y * ptr[step+1];
    return (ret_val + 512) / 1024;
  }

  // this is the standard case (simple, not speed optimized yet):

  // scaling:
  const int scaling = (int)(4194304.0 / area);
  const int scaling2 = int(float(scaling) * area / 1024.0);
  CV_Assert(scaling2 != 0);

  // the integral image is larger:
  const int integralcols = imagecols + 1;

  // calculate borders
  const float x_1 = xf - sigma_half;
  const float x1 = xf + sigma_half;
  const float y_1 = yf - sigma_half;
  const float y1 = yf + sigma_half;

  const int x_left = int(x_1 + 0.5);
  const int y_top = int(y_1 + 0.5);
  const int x_right = int(x1 + 0.5);
  const int y_bottom = int(y1 + 0.5);

  // overlap area - multiplication factors:
  const float r_x_1 = float(x_left) - x_1 + 0.5f;
  const float r_y_1 = float(y_top) - y_1 + 0.5f;
  const float r_x1 = x1 - float(x_right) + 0.5f;
  const float r_y1 = y1 - float(y_bottom) + 0.5f;
  const int dx = x_right - x_left - 1;
  const int dy = y_bottom - y_top - 1;
  const int A = (int)((r_x_1 * r_y_1) * scaling);
  const int B = (int)((r_x1 * r_y_1) * scaling);
  const int C = (int)((r_x1 * r_y1) * scaling);
  const int D = (int)((r_x_1 * r_y1) * scaling);
  const int r_x_1_i = (int)(r_x_1 * scaling);
  const int r_y_1_i = (int)(r_y_1 * scaling);
  const int r_x1_i = (int)(r_x1 * scaling);
  const int r_y1_i = (int)(r_y1 * scaling);

  if (dx + dy > 2)
  {
    // now the calculation:
    const uchar* ptr = image.ptr() + x_left + imagecols * y_top;
    // first the corners:
    ret_val = A * int(*ptr);
    ptr += dx + 1;
    ret_val += B * int(*ptr);
    ptr += dy * imagecols + 1;
    ret_val += C * int(*ptr);
    ptr -= dx + 1;
    ret_val += D * int(*ptr);

    // next the edges:
    const int* ptr_integral = integral.ptr<int>() + x_left + integralcols * y_top + 1;
    // find a simple path through the different surface corners
    const int tmp1 = (*ptr_integral);
    ptr_integral += dx;
    const int tmp2 = (*ptr_integral);
    ptr_integral += integralcols;
    const int tmp3 = (*ptr_integral);
    ptr_integral++;
    const int tmp4 = (*ptr_integral);
    ptr_integral += dy * integralcols;
    const int tmp5 = (*ptr_integral);
    ptr_integral--;
    const int tmp6 = (*ptr_integral);
    ptr_integral += integralcols;
    const int tmp7 = (*ptr_integral);
    ptr_integral -= dx;
    const int tmp8 = (*ptr_integral);
    ptr_integral -= integralcols;
    const int tmp9 = (*ptr_integral);
    ptr_integral--;
    const int tmp10 = (*ptr_integral);
    ptr_integral -= dy * integralcols;
    const int tmp11 = (*ptr_integral);
    ptr_integral++;
    const int tmp12 = (*ptr_integral);

    // assign the weighted surface integrals:
    const int upper = (tmp3 - tmp2 + tmp1 - tmp12) * r_y_1_i;
    const int middle = (tmp6 - tmp3 + tmp12 - tmp9) * scaling;
    const int left = (tmp9 - tmp12 + tmp11 - tmp10) * r_x_1_i;
    const int right = (tmp5 - tmp4 + tmp3 - tmp6) * r_x1_i;
    const int bottom = (tmp7 - tmp6 + tmp9 - tmp8) * r_y1_i;

    return (ret_val + upper + middle + left + right + bottom + scaling2 / 2) / scaling2;
  }

  // now the calculation:
  const uchar* ptr = image.ptr() + x_left + imagecols * y_top;
  // first row:
  ret_val = A * int(*ptr);
  ptr++;
  const uchar* end1 = ptr + dx;
  for (; ptr < end1; ptr++)
  {
    ret_val += r_y_1_i * int(*ptr);
  }
  ret_val += B * int(*ptr);
  // middle ones:
  ptr += imagecols - dx - 1;
  const uchar* end_j = ptr + dy * imagecols;
  for (; ptr < end_j; ptr += imagecols - dx - 1)
  {
    ret_val += r_x_1_i * int(*ptr);
    ptr++;
    const uchar* end2 = ptr + dx;
    for (; ptr < end2; ptr++)
    {
      ret_val += int(*ptr) * scaling;
    }
    ret_val += r_x1_i * int(*ptr);
  }
  // last row:
  ret_val += D * int(*ptr);
  ptr++;
  const uchar* end3 = ptr + dx;
  for (; ptr < end3; ptr++)
  {
    ret_val += r_y1_i * int(*ptr);
  }
  ret_val += C * int(*ptr);

  return (ret_val + scaling2 / 2) / scaling2;
}






BriskScaleSpace1::BriskScaleSpace1(int _octaves)
{
  if (_octaves == 0)
    layers_ = 1;
  else
    layers_ = 2 * _octaves;
 //cout<<"Ocataves and Layers"<<_octaves<<layers_<<"\n";
}
BriskScaleSpace1::~BriskScaleSpace1()
{

}

//construct the image pyramids
void
BriskScaleSpace1::constructPyramid(const cv::Mat& image)
{

  // set correct size:
  pyramid_.clear();

   // fill the pyramid:
  pyramid_.push_back(BriskLayer1(image.clone()));
  if (layers_ > 1)
  {
    pyramid_.push_back(BriskLayer1(pyramid_.back(), BriskLayer1::CommonParams::TWOTHIRDSAMPLE));
  }
  const int octaves2 = layers_;

  for (uchar i = 2; i < octaves2; i += 2)
  {
    pyramid_.push_back(BriskLayer1(pyramid_[i - 2], BriskLayer1::CommonParams::HALFSAMPLE));
    pyramid_.push_back(BriskLayer1(pyramid_[i - 1], BriskLayer1::CommonParams::HALFSAMPLE));
  }

}

 void
BriskScaleSpace1::getKeypoints(const int threshold_, std::vector<cv::KeyPoint>& keypoints)
{
 // make sure keypoints is empty
  keypoints.resize(0);
  keypoints.reserve(2000);

  // assign thresholds
  int safeThreshold_ = (int)(threshold_ * safetyFactor_);
  std::vector<std::vector<cv::KeyPoint> > agastPoints;
  agastPoints.resize(layers_);
  #pragma omp parallel for
   for (int i = 0; i < layers_; i++)
  { //cout<<"heu\n";
    // call OAST16_9 without nms
    BriskLayer1& l = pyramid_[i];                        //parallelize
    l.getAgastPoints(safeThreshold_, agastPoints[i]);

  }

   if (layers_ == 1)
  {
    // just do a simple 2d subpixel refinement...
    const size_t num = agastPoints[0].size();
    for (size_t n = 0; n < num; n++)          //parallelize
    {
      const cv::Point2f& point = agastPoints.at(0)[n].pt;

      if (!isMax2D(0, (int)point.x, (int)point.y))
        continue;

        // let's do the subpixel and float scale refinement:
      BriskLayer1& l = pyramid_[0];
      int s_0_0 = l.getAgastScore(point.x - 1, point.y - 1, 1);
      int s_1_0 = l.getAgastScore(point.x, point.y - 1, 1);
      int s_2_0 = l.getAgastScore(point.x + 1, point.y - 1, 1);
      int s_2_1 = l.getAgastScore(point.x + 1, point.y, 1);
      int s_1_1 = l.getAgastScore(point.x, point.y, 1);
      int s_0_1 = l.getAgastScore(point.x - 1, point.y, 1);
      int s_0_2 = l.getAgastScore(point.x - 1, point.y + 1, 1);
      int s_1_2 = l.getAgastScore(point.x, point.y + 1, 1);
      int s_2_2 = l.getAgastScore(point.x + 1, point.y + 1, 1);
      float delta_x, delta_y;
      float max = subpixel2D(s_0_0, s_0_1, s_0_2, s_1_0, s_1_1, s_1_2, s_2_0, s_2_1, s_2_2, delta_x, delta_y);


      keypoints.push_back(cv::KeyPoint(float(point.x) + delta_x, float(point.y) + delta_y, basicSize_, -1, max, 0));

      //cout<<"PRint"<<keypoints.size();

    }
    return;

  }

 float x, y, scale, score;
  #pragma omp parallel for
  for (int i = 0; i < layers_; i++)
  {
    BriskLayer1& l = pyramid_[i];

    const size_t num = agastPoints[i].size();
    //cout<<agastPoints[i];
    if (i == layers_ - 1)
    {
      for (size_t n = 0; n < num; n++)
      {
        const cv::Point2f& point = agastPoints.at(i)[n].pt;
        // consider only 2D maxima...
        if (!isMax2D(i, (int)point.x, (int)point.y))
          continue;
        bool ismax;
        float dx, dy;
        getScoreMaxBelow(i, (int)point.x, (int)point.y, l.getAgastScore(point.x, point.y, safeThreshold_), ismax, dx, dy);
        if (!ismax)
          continue;
        int s_0_0, s_0_1, s_0_2, s_1_0, s_1_1, s_1_2, s_2_0, s_2_1, s_2_2;
        // get the patch on this layer:
        #pragma omp parallel sections
        {
        #pragma omp section
        s_0_0 = l.getAgastScore(point.x - 1, point.y - 1, 1);
        #pragma omp section
        s_1_0 = l.getAgastScore(point.x, point.y - 1, 1);
        #pragma omp section
        s_2_0 = l.getAgastScore(point.x + 1, point.y - 1, 1);
        #pragma omp section
        s_2_1 = l.getAgastScore(point.x + 1, point.y, 1);
        #pragma omp section
        s_1_1 = l.getAgastScore(point.x, point.y, 1);
        #pragma omp section
        s_0_1 = l.getAgastScore(point.x - 1, point.y, 1);
        #pragma omp section
        s_0_2 = l.getAgastScore(point.x - 1, point.y + 1, 1);
        #pragma omp section
        s_1_2 = l.getAgastScore(point.x, point.y + 1, 1);
        #pragma omp section
        s_2_2 = l.getAgastScore(point.x + 1, point.y + 1, 1);
        }

        float delta_x, delta_y;
        float max = subpixel2D(s_0_0, s_0_1, s_0_2, s_1_0, s_1_1, s_1_2, s_2_0, s_2_1, s_2_2, delta_x, delta_y);

        // store:
        keypoints.push_back(
            cv::KeyPoint((float(point.x) + delta_x) * l.scale() + l.offset(),
                         (float(point.y) + delta_y) * l.scale() + l.offset(), basicSize_ * l.scale(), -1, max, i));
        //cout<<"Print"<<keypoints.size();
      }
    }

  else
    {
      // not the last layer:
      for (size_t n = 0; n < num; n++)
      {
          const cv::Point2f& point = agastPoints.at(i)[n].pt;

        // first check if it is a maximum:
        if (!isMax2D(i, (int)point.x, (int)point.y))
          continue;

        // let's do the subpixel and float scale refinement:
        bool ismax=false;
        score = refine3D(i, (int)point.x, (int)point.y, x, y, scale, ismax);
        if (!ismax)
        {
          continue;
        }

        // finally store the detected keypoint:
        if (score > float(threshold_))
        {
          keypoints.push_back(cv::KeyPoint(x, y, basicSize_ * scale, -1, score, i));
        }
      }
    }
  }

  //cout<<"AgastPoints"<<agastPoints.size();
}

inline bool
BriskScaleSpace1::isMax2D(const int layer, const int x_layer, const int y_layer)
{
  const cv::Mat& scores = pyramid_[layer].scores();
  const int scorescols = scores.cols;
  const uchar* data = scores.ptr() + y_layer * scorescols + x_layer;
  // decision tree:
  const uchar center = (*data);
  data--;
  const uchar s_10 = *data;
  if (center < s_10)
    return false;
  data += 2;
  const uchar s10 = *data;
  if (center < s10)
    return false;
  data -= (scorescols + 1);

  const uchar s0_1 = *data;
  if (center < s0_1)
    return false;
  data += 2 * scorescols;             //SEction parllalizaton may be
  const uchar s01 = *data;
  if (center < s01)
    return false;
  data--;
  const uchar s_11 = *data;
  if (center < s_11)
    return false;
  data += 2;
  const uchar s11 = *data;
  if (center < s11)
    return false;
  data -= 2 * scorescols;
  const uchar s1_1 = *data;
  if (center < s1_1)
    return false;
  data -= 2;
  const uchar s_1_1 = *data;
  if (center < s_1_1)
    return false;

  // reject neighbor maxima
   std::vector<int> delta;
  // put together a list of 2d-offsets to where the maximum is also reached
  if (center == s_1_1)
  {
    delta.push_back(-1);
    delta.push_back(-1);
  }
  if (center == s0_1)
  {
    delta.push_back(0);
    delta.push_back(-1);
  }
  if (center == s1_1)
  {
    delta.push_back(1);
    delta.push_back(-1);
  }
  if (center == s_10)
  {
    delta.push_back(-1);
    delta.push_back(0);
  }
  if (center == s10)
  {
    delta.push_back(1);
    delta.push_back(0);
  }
  if (center == s_11)
  {
    delta.push_back(-1);
    delta.push_back(1);
  }
  if (center == s01)
  {
    delta.push_back(0);
    delta.push_back(1);
  }
  if (center == s11)
  {
    delta.push_back(1);
    delta.push_back(1);
  }

  const unsigned int deltasize = (unsigned int)delta.size();
  if (deltasize != 0)
  {
    // in this case, we have to analyze the situation more carefully:
    // the values are gaussian blurred and then we really decide
    int smoothedcenter = 4 * center + 2 * (s_10 + s10 + s0_1 + s01) + s_1_1 + s1_1 + s_11 + s11;
    for (unsigned int i = 0; i < deltasize; i += 2)
    {
      data = scores.ptr() + (y_layer - 1 + delta[i + 1]) * scorescols + x_layer + delta[i] - 1;
      int othercenter = *data;
      data++;
      othercenter += 2 * (*data);
      data++;
      othercenter += *data;
      data += scorescols;
      othercenter += 2 * (*data);
      data--;
      othercenter += 4 * (*data);
      data--;
      othercenter += 2 * (*data);
      data += scorescols;
      othercenter += *data;
      data++;
      othercenter += 2 * (*data);
      data++;
      othercenter += *data;
      if (othercenter > smoothedcenter)
        return false;
    }
  }
  return true;
}

inline float
BriskScaleSpace1::refine1D(const float s_05, const float s0, const float s05, float& max) const
{
  int i_05 = int(1024.0 * s_05 + 0.5);
  int i0 = int(1024.0 * s0 + 0.5);
  int i05 = int(1024.0 * s05 + 0.5);

  //   16.0000  -24.0000    8.0000
  //  -40.0000   54.0000  -14.0000
  //   24.0000  -27.0000    6.0000

  int three_a = 16 * i_05 - 24 * i0 + 8 * i05;
  // second derivative must be negative:
 if (three_a >= 0)
 {
   if (s0 >= s_05 && s0 >= s05)
   {
     max = s0;
     return 1.0f;
   }
   if (s_05 >= s0 && s_05 >= s05)
   {
     max = s_05;
     return 0.75f;
   }
   if (s05 >= s0 && s05 >= s_05)
   {
     max = s05;
     return 1.5f;
   }
 }
  // calculate max location:
  int three_b = -40 * i_05 + 54 * i0 - 14 * i05;
  float ret_val = -float(three_b) / float(2 * three_a);
  // saturate and return
  if (ret_val < 0.75)
    ret_val = 0.75;
  else if (ret_val > 1.5)
    ret_val = 1.5; // allow to be slightly off bounds ...?
  int three_c = +24 * i_05 - 27 * i0 + 6 * i05;
  max = float(three_c) + float(three_a) * ret_val * ret_val + float(three_b) * ret_val;
  max /= 3072.0f;
  return ret_val;
}

inline float
BriskScaleSpace1::refine1D_1(const float s_05, const float s0, const float s05, float& max) const
{
  int i_05 = int(1024.0 * s_05 + 0.5);
  int i0 = int(1024.0 * s0 + 0.5);
  int i05 = int(1024.0 * s05 + 0.5);

  //  4.5000   -9.0000    4.5000
  //-10.5000   18.0000   -7.5000
  //  6.0000   -8.0000    3.0000

  int two_a = 9 * i_05 - 18 * i0 + 9 * i05;
  // second derivative must be negative:
  if (two_a >= 0)
  {
    if (s0 >= s_05 && s0 >= s05)
    {
      max = s0;
      return 1.0f;
    }
    if (s_05 >= s0 && s_05 >= s05)
    {
      max = s_05;
      return 0.6666666666666666666666666667f;
    }
    if (s05 >= s0 && s05 >= s_05)
    {
      max = s05;
      return 1.3333333333333333333333333333f;
    }
  }

  int two_b = -21 * i_05 + 36 * i0 - 15 * i05;
  // calculate max location:
  float ret_val = -float(two_b) / float(2 * two_a);
  // saturate and return
  if (ret_val < 0.6666666666666666666666666667f)
    ret_val = 0.666666666666666666666666667f;
  else if (ret_val > 1.33333333333333333333333333f)
    ret_val = 1.333333333333333333333333333f;
  int two_c = +12 * i_05 - 16 * i0 + 6 * i05;
  max = float(two_c) + float(two_a) * ret_val * ret_val + float(two_b) * ret_val;
  max /= 2048.0f;
  return ret_val;
}


inline float
BriskScaleSpace1::refine1D_2(const float s_05, const float s0, const float s05, float& max) const
{
  int i_05 = int(1024.0 * s_05 + 0.5);
  int i0 = int(1024.0 * s0 + 0.5);
  int i05 = int(1024.0 * s05 + 0.5);

  //   18.0000  -30.0000   12.0000
  //  -45.0000   65.0000  -20.0000
  //   27.0000  -30.0000    8.0000

  int a = 2 * i_05 - 4 * i0 + 2 * i05;
  // second derivative must be negative:
  if (a >= 0)
  {
    if (s0 >= s_05 && s0 >= s05)
    {
      max = s0;
      return 1.0f;
    }
    if (s_05 >= s0 && s_05 >= s05)
    {
      max = s_05;
      return 0.7f;
    }
    if (s05 >= s0 && s05 >= s_05)
    {
      max = s05;
      return 1.5f;
    }
  }

  int b = -5 * i_05 + 8 * i0 - 3 * i05;
  // calculate max location:
  float ret_val = -float(b) / float(2 * a);
  // saturate and return
  if (ret_val < 0.7f)
    ret_val = 0.7f;
  else if (ret_val > 1.5f)
    ret_val = 1.5f; // allow to be slightly off bounds ...?
  int c = +3 * i_05 - 3 * i0 + 1 * i05;
  max = float(c) + float(a) * ret_val * ret_val + float(b) * ret_val;
  max /= 1024;
  return ret_val;
}


inline float
BriskScaleSpace1::subpixel2D(const int s_0_0, const int s_0_1, const int s_0_2, const int s_1_0, const int s_1_1,
                            const int s_1_2, const int s_2_0, const int s_2_1, const int s_2_2, float& delta_x,
                            float& delta_y) const
{

  // the coefficients of the 2d quadratic function least-squares fit:
  int tmp1 = s_0_0 + s_0_2 - 2 * s_1_1 + s_2_0 + s_2_2;
  int coeff1 = 3 * (tmp1 + s_0_1 - ((s_1_0 + s_1_2) << 1) + s_2_1);
  int coeff2 = 3 * (tmp1 - ((s_0_1 + s_2_1) << 1) + s_1_0 + s_1_2);
  int tmp2 = s_0_2 - s_2_0;
  int tmp3 = (s_0_0 + tmp2 - s_2_2);
  int tmp4 = tmp3 - 2 * tmp2;
  int coeff3 = -3 * (tmp3 + s_0_1 - s_2_1);
  int coeff4 = -3 * (tmp4 + s_1_0 - s_1_2);
  int coeff5 = (s_0_0 - s_0_2 - s_2_0 + s_2_2) << 2;
  int coeff6 = -(s_0_0 + s_0_2 - ((s_1_0 + s_0_1 + s_1_2 + s_2_1) << 1) - 5 * s_1_1 + s_2_0 + s_2_2) << 1;

  // 2nd derivative test:
  int H_det = 4 * coeff1 * coeff2 - coeff5 * coeff5;

  if (H_det == 0)
  {
    delta_x = 0.0f;
    delta_y = 0.0f;
    return float(coeff6) / 18.0f;
  }

  if (!(H_det > 0 && coeff1 < 0))
  {
    // The maximum must be at the one of the 4 patch corners.
    int tmp_max = coeff3 + coeff4 + coeff5;
    delta_x = 1.0f;
    delta_y = 1.0f;

    int tmp = -coeff3 + coeff4 - coeff5;
    if (tmp > tmp_max)
    {
      tmp_max = tmp;
      delta_x = -1.0f;
      delta_y = 1.0f;
    }
    tmp = coeff3 - coeff4 - coeff5;
    if (tmp > tmp_max)
    {
      tmp_max = tmp;
      delta_x = 1.0f;
      delta_y = -1.0f;
    }
    tmp = -coeff3 - coeff4 + coeff5;
    if (tmp > tmp_max)
    {
      tmp_max = tmp;
      delta_x = -1.0f;
      delta_y = -1.0f;
    }
    return float(tmp_max + coeff1 + coeff2 + coeff6) / 18.0f;
  }

  // this is hopefully the normal outcome of the Hessian test
  delta_x = float(2 * coeff2 * coeff3 - coeff4 * coeff5) / float(-H_det);
  delta_y = float(2 * coeff1 * coeff4 - coeff3 * coeff5) / float(-H_det);
  // TODO: this is not correct, but easy, so perform a real boundary maximum search:
  bool tx = false;
  bool tx_ = false;
  bool ty = false;
  bool ty_ = false;
  if (delta_x > 1.0)
    tx = true;
  else if (delta_x < -1.0)
    tx_ = true;
  if (delta_y > 1.0)
    ty = true;
  if (delta_y < -1.0)
    ty_ = true;

  if (tx || tx_ || ty || ty_)
  {
    // get two candidates:
    float delta_x1 = 0.0f, delta_x2 = 0.0f, delta_y1 = 0.0f, delta_y2 = 0.0f;
    if (tx)
    {
      delta_x1 = 1.0f;
      delta_y1 = -float(coeff4 + coeff5) / float(2 * coeff2);
      if (delta_y1 > 1.0f)
        delta_y1 = 1.0f;
      else if (delta_y1 < -1.0f)
        delta_y1 = -1.0f;
    }
    else if (tx_)
    {
      delta_x1 = -1.0f;
      delta_y1 = -float(coeff4 - coeff5) / float(2 * coeff2);
      if (delta_y1 > 1.0f)
        delta_y1 = 1.0f;
      else if (delta_y1 < -1.0)
        delta_y1 = -1.0f;
    }
    if (ty)
    {
      delta_y2 = 1.0f;
      delta_x2 = -float(coeff3 + coeff5) / float(2 * coeff1);
      if (delta_x2 > 1.0f)
        delta_x2 = 1.0f;
      else if (delta_x2 < -1.0f)
        delta_x2 = -1.0f;
    }
    else if (ty_)
    {
      delta_y2 = -1.0f;
      delta_x2 = -float(coeff3 - coeff5) / float(2 * coeff1);
      if (delta_x2 > 1.0f)
        delta_x2 = 1.0f;
      else if (delta_x2 < -1.0f)
        delta_x2 = -1.0f;
    }
    // insert both options for evaluation which to pick
    float max1 = (coeff1 * delta_x1 * delta_x1 + coeff2 * delta_y1 * delta_y1 + coeff3 * delta_x1 + coeff4 * delta_y1
                  + coeff5 * delta_x1 * delta_y1 + coeff6)
                 / 18.0f;
    float max2 = (coeff1 * delta_x2 * delta_x2 + coeff2 * delta_y2 * delta_y2 + coeff3 * delta_x2 + coeff4 * delta_y2
                  + coeff5 * delta_x2 * delta_y2 + coeff6)
                 / 18.0f;
    if (max1 > max2)
    {
      delta_x = delta_x1;
      delta_y = delta_y1;
      return max1;
    }
    else
    {
      delta_x = delta_x2;
      delta_y = delta_y2;
      return max2;
    }
  }

  // this is the case of the maximum inside the boundaries:
  return (coeff1 * delta_x * delta_x + coeff2 * delta_y * delta_y + coeff3 * delta_x + coeff4 * delta_y
          + coeff5 * delta_x * delta_y + coeff6)
         / 18.0f;
}

inline float
BriskScaleSpace1::refine3D(const int layer, const int x_layer, const int y_layer, float& x, float& y, float& scale,
                          bool& ismax) const
{
  ismax = true;
  const BriskLayer1& thisLayer = pyramid_[layer];
  const int center = thisLayer.getAgastScore(x_layer, y_layer, 1);

  float delta_x_above = 0, delta_y_above = 0;
  float max_above = getScoreMaxAbove(layer, x_layer, y_layer, center, ismax, delta_x_above, delta_y_above);

  if (!ismax)
    return 0.0f;

  float max; // to be returned

  if (layer % 2 == 0)
  { // on octave
    // treat the patch below:
    float delta_x_below, delta_y_below;
    float max_below_float;
    int max_below = 0;
    if (layer == 0)
    {
      // guess the lower intra octave...
      const BriskLayer1& l = pyramid_[0];
      int s_0_0 = l.getAgastScore_5_8(x_layer - 1, y_layer - 1, 1);
      max_below = s_0_0;
      int s_1_0 = l.getAgastScore_5_8(x_layer, y_layer - 1, 1);
      max_below = std::max(s_1_0, max_below);
      int s_2_0 = l.getAgastScore_5_8(x_layer + 1, y_layer - 1, 1);
      max_below = std::max(s_2_0, max_below);
      int s_2_1 = l.getAgastScore_5_8(x_layer + 1, y_layer, 1);
      max_below = std::max(s_2_1, max_below);
      int s_1_1 = l.getAgastScore_5_8(x_layer, y_layer, 1);
      max_below = std::max(s_1_1, max_below);
      int s_0_1 = l.getAgastScore_5_8(x_layer - 1, y_layer, 1);
      max_below = std::max(s_0_1, max_below);
      int s_0_2 = l.getAgastScore_5_8(x_layer - 1, y_layer + 1, 1);
      max_below = std::max(s_0_2, max_below);
      int s_1_2 = l.getAgastScore_5_8(x_layer, y_layer + 1, 1);
      max_below = std::max(s_1_2, max_below);
      int s_2_2 = l.getAgastScore_5_8(x_layer + 1, y_layer + 1, 1);
      max_below = std::max(s_2_2, max_below);


      subpixel2D(s_0_0, s_0_1, s_0_2, s_1_0, s_1_1, s_1_2, s_2_0, s_2_1, s_2_2, delta_x_below, delta_y_below);
      max_below_float = (float)max_below;
    }
    else
    {
      max_below_float = getScoreMaxBelow(layer, x_layer, y_layer, center, ismax, delta_x_below, delta_y_below);
      if (!ismax)
        return 0;
    }

    // get the patch on this layer:
    int s_0_0 = thisLayer.getAgastScore(x_layer - 1, y_layer - 1, 1);
    int s_1_0 = thisLayer.getAgastScore(x_layer, y_layer - 1, 1);
    int s_2_0 = thisLayer.getAgastScore(x_layer + 1, y_layer - 1, 1);
    int s_2_1 = thisLayer.getAgastScore(x_layer + 1, y_layer, 1);
    int s_1_1 = thisLayer.getAgastScore(x_layer, y_layer, 1);
    int s_0_1 = thisLayer.getAgastScore(x_layer - 1, y_layer, 1);
    int s_0_2 = thisLayer.getAgastScore(x_layer - 1, y_layer + 1, 1);
    int s_1_2 = thisLayer.getAgastScore(x_layer, y_layer + 1, 1);
    int s_2_2 = thisLayer.getAgastScore(x_layer + 1, y_layer + 1, 1);
    float delta_x_layer, delta_y_layer;
    float max_layer = subpixel2D(s_0_0, s_0_1, s_0_2, s_1_0, s_1_1, s_1_2, s_2_0, s_2_1, s_2_2, delta_x_layer,
                                 delta_y_layer);
//RElative scales
    if (layer == 0)
    {
      scale = refine1D_2(max_below_float, std::max(float(center), max_layer), max_above, max);
    }
    else
      scale = refine1D(max_below_float, std::max(float(center), max_layer), max_above, max);

    if (scale > 1.0)
    {
      // interpolate the position:
      const float r0 = (1.5f - scale) / .5f;
      const float r1 = 1.0f - r0;
      x = (r0 * delta_x_layer + r1 * delta_x_above + float(x_layer)) * thisLayer.scale() + thisLayer.offset();
      y = (r0 * delta_y_layer + r1 * delta_y_above + float(y_layer)) * thisLayer.scale() + thisLayer.offset();
    }

    else
    {
      if (layer == 0)
      {
        // interpolate the position:
        const float r0 = (scale - 0.5f) / 0.5f;
        const float r_1 = 1.0f - r0;
        x = r0 * delta_x_layer + r_1 * delta_x_below + float(x_layer);
        y = r0 * delta_y_layer + r_1 * delta_y_below + float(y_layer);
      }
      else
      {
        // interpolate the position:
        const float r0 = (scale - 0.75f) / 0.25f;
        const float r_1 = 1.0f - r0;
        x = (r0 * delta_x_layer + r_1 * delta_x_below + float(x_layer)) * thisLayer.scale() + thisLayer.offset();
        y = (r0 * delta_y_layer + r_1 * delta_y_below + float(y_layer)) * thisLayer.scale() + thisLayer.offset();
      }
    }
  }
  else
  {
    // on intra
    // check the patch below:
    float delta_x_below, delta_y_below;
    float max_below = getScoreMaxBelow(layer, x_layer, y_layer, center, ismax, delta_x_below, delta_y_below);
    if (!ismax)
      return 0.0f;

      // get the patch on this layer:
     int s_0_0 = thisLayer.getAgastScore(x_layer - 1, y_layer - 1, 1);
     int s_1_0 = thisLayer.getAgastScore(x_layer, y_layer - 1, 1);
     int s_2_0 = thisLayer.getAgastScore(x_layer + 1, y_layer - 1, 1);
     int s_2_1 = thisLayer.getAgastScore(x_layer + 1, y_layer, 1);
     int s_1_1 = thisLayer.getAgastScore(x_layer, y_layer, 1);
     int s_0_1 = thisLayer.getAgastScore(x_layer - 1, y_layer, 1);
     int s_0_2 = thisLayer.getAgastScore(x_layer - 1, y_layer + 1, 1);
     int s_1_2 = thisLayer.getAgastScore(x_layer, y_layer + 1, 1);
     int s_2_2 = thisLayer.getAgastScore(x_layer + 1, y_layer + 1, 1);
     float delta_x_layer, delta_y_layer;
     float max_layer = subpixel2D(s_0_0, s_0_1, s_0_2, s_1_0, s_1_1, s_1_2, s_2_0, s_2_1, s_2_2, delta_x_layer,
                                  delta_y_layer);

     // calculate the relative scale (1D maximum):
     scale = refine1D_1(max_below, std::max(float(center), max_layer), max_above, max);
     if (scale > 1.0)
     {
       // interpolate the position:
       const float r0 = 4.0f - scale * 3.0f;
       const float r1 = 1.0f - r0;
       x = (r0 * delta_x_layer + r1 * delta_x_above + float(x_layer)) * thisLayer.scale() + thisLayer.offset();
       y = (r0 * delta_y_layer + r1 * delta_y_above + float(y_layer)) * thisLayer.scale() + thisLayer.offset();
     }
     else
     {
       // interpolate the position:
       const float r0 = scale * 3.0f - 2.0f;
       const float r_1 = 1.0f - r0;
       x = (r0 * delta_x_layer + r_1 * delta_x_below + float(x_layer)) * thisLayer.scale() + thisLayer.offset();
       y = (r0 * delta_y_layer + r_1 * delta_y_below + float(y_layer)) * thisLayer.scale() + thisLayer.offset();
     }
   }

   // calculate the absolute scale:
   scale *= thisLayer.scale();

   // that's it, return the refined maximum:
   return max;
 }


 inline float
 BriskScaleSpace1::getScoreMaxAbove(const int layer, const int x_layer, const int y_layer, const int threshold,
                                   bool& ismax, float& dx, float& dy) const
 {

   ismax = false;
   // relevant floating point coordinates
   float x_1;
   float x1;
   float y_1;
   float y1;

   // the layer above
   CV_Assert(layer + 1 < layers_);
   const BriskLayer1& layerAbove = pyramid_[layer + 1];

   if (layer % 2 == 0)
   {
     // octave
     x_1 = float(4 * (x_layer) - 1 - 2) / 6.0f;
     x1 = float(4 * (x_layer) - 1 + 2) / 6.0f;
     y_1 = float(4 * (y_layer) - 1 - 2) / 6.0f;
     y1 = float(4 * (y_layer) - 1 + 2) / 6.0f;
   }
   else
   {
     // intra
     x_1 = float(6 * (x_layer) - 1 - 3) / 8.0f;
     x1 = float(6 * (x_layer) - 1 + 3) / 8.0f;
     y_1 = float(6 * (y_layer) - 1 - 3) / 8.0f;
     y1 = float(6 * (y_layer) - 1 + 3) / 8.0f;
   }

   // check the first row
   int max_x = (int)x_1 + 1;
   int max_y = (int)y_1 + 1;
   float tmp_max;
   float maxval = (float)layerAbove.getAgastScore(x_1, y_1, 1);
   if (maxval > threshold)
     return 0;
   for (int x = (int)x_1 + 1; x <= int(x1); x++)
   {
     tmp_max = (float)layerAbove.getAgastScore(float(x), y_1, 1);
     if (tmp_max > threshold)
       return 0;
     if (tmp_max > maxval)
     {
       maxval = tmp_max;
       max_x = x;
     }
   }
   tmp_max = (float)layerAbove.getAgastScore(x1, y_1, 1);
   if (tmp_max > threshold)
     return 0;
   if (tmp_max > maxval)
   {
     maxval = tmp_max;
     max_x = int(x1);
   }

   // middle rows
   for (int y = (int)y_1 + 1; y <= int(y1); y++)
   {
     tmp_max = (float)layerAbove.getAgastScore(x_1, float(y), 1);
     if (tmp_max > threshold)
       return 0;
     if (tmp_max > maxval)
     {
       maxval = tmp_max;
       max_x = int(x_1 + 1);
       max_y = y;
     }
     for (int x = (int)x_1 + 1; x <= int(x1); x++)
     {
       tmp_max = (float)layerAbove.getAgastScore(x, y, 1);
       if (tmp_max > threshold)
         return 0;
       if (tmp_max > maxval)
       {
         maxval = tmp_max;
         max_x = x;
         max_y = y;
       }
     }
     tmp_max = (float)layerAbove.getAgastScore(x1, float(y), 1);
     if (tmp_max > threshold)
       return 0;
     if (tmp_max > maxval)
     {
       maxval = tmp_max;
       max_x = int(x1);
       max_y = y;
     }
   }

   // bottom row
   tmp_max = (float)layerAbove.getAgastScore(x_1, y1, 1);
   if (tmp_max > maxval)
   {
     maxval = tmp_max;
     max_x = int(x_1 + 1);
     max_y = int(y1);
   }
   for (int x = (int)x_1 + 1; x <= int(x1); x++)
   {
     tmp_max = (float)layerAbove.getAgastScore(float(x), y1, 1);
     if (tmp_max > maxval)
     {
       maxval = tmp_max;
       max_x = x;
       max_y = int(y1);
     }
   }
   tmp_max = (float)layerAbove.getAgastScore(x1, y1, 1);
   if (tmp_max > maxval)
   {
     maxval = tmp_max;
     max_x = int(x1);
     max_y = int(y1);
   }

   //find dx/dy:
   int s_0_0 = layerAbove.getAgastScore(max_x - 1, max_y - 1, 1);
   int s_1_0 = layerAbove.getAgastScore(max_x, max_y - 1, 1);
   int s_2_0 = layerAbove.getAgastScore(max_x + 1, max_y - 1, 1);
   int s_2_1 = layerAbove.getAgastScore(max_x + 1, max_y, 1);
   int s_1_1 = layerAbove.getAgastScore(max_x, max_y, 1);
   int s_0_1 = layerAbove.getAgastScore(max_x - 1, max_y, 1);
   int s_0_2 = layerAbove.getAgastScore(max_x - 1, max_y + 1, 1);
   int s_1_2 = layerAbove.getAgastScore(max_x, max_y + 1, 1);
   int s_2_2 = layerAbove.getAgastScore(max_x + 1, max_y + 1, 1);
   float dx_1, dy_1;
   float refined_max = subpixel2D(s_0_0, s_0_1, s_0_2, s_1_0, s_1_1, s_1_2, s_2_0, s_2_1, s_2_2, dx_1, dy_1);

   // calculate dx/dy in above coordinates
   float real_x = float(max_x) + dx_1;
   float real_y = float(max_y) + dy_1;
   bool returnrefined = true;
   if (layer % 2 == 0)
   {
     dx = (real_x * 6.0f + 1.0f) / 4.0f - float(x_layer);
     dy = (real_y * 6.0f + 1.0f) / 4.0f - float(y_layer);
   }
   else
   {
     dx = (real_x * 8.0f + 1.0f) / 6.0f - float(x_layer);
     dy = (real_y * 8.0f + 1.0f) / 6.0f - float(y_layer);
   }

   // saturate
   if (dx > 1.0f)
   {
     dx = 1.0f;
     returnrefined = false;
   }
   if (dx < -1.0f)
   {
     dx = -1.0f;
     returnrefined = false;
   }
   if (dy > 1.0f)
   {
     dy = 1.0f;
     returnrefined = false;
   }
   if (dy < -1.0f)
   {
     dy = -1.0f;
     returnrefined = false;
   }

   // done and ok.
   ismax = true;
   if (returnrefined)
   {
     return std::max(refined_max, maxval);
   }
   return maxval;
 }


 inline float
BriskScaleSpace1::getScoreMaxBelow(const int layer, const int x_layer, const int y_layer, const int threshold,
                                  bool& ismax, float& dx, float& dy) const
{
  ismax = false;

  // relevant floating point coordinates
  float x_1;
  float x1;
  float y_1;
  float y1;

  if (layer % 2 == 0)
  {
    // octave
    x_1 = float(8 * (x_layer) + 1 - 4) / 6.0f;
    x1 = float(8 * (x_layer) + 1 + 4) / 6.0f;
    y_1 = float(8 * (y_layer) + 1 - 4) / 6.0f;
    y1 = float(8 * (y_layer) + 1 + 4) / 6.0f;
  }
  else
  {
    x_1 = float(6 * (x_layer) + 1 - 3) / 4.0f;
    x1 = float(6 * (x_layer) + 1 + 3) / 4.0f;
    y_1 = float(6 * (y_layer) + 1 - 3) / 4.0f;
    y1 = float(6 * (y_layer) + 1 + 3) / 4.0f;
  }

  // the layer below
  CV_Assert(layer > 0);
  const BriskLayer1& layerBelow = pyramid_[layer - 1];

  // check the first row
  int max_x = (int)x_1 + 1;
  int max_y = (int)y_1 + 1;
  float tmp_max;
  float max = (float)layerBelow.getAgastScore(x_1, y_1, 1);
  if (max > threshold)
    return 0;
  for (int x = (int)x_1 + 1; x <= int(x1); x++)
  {
    tmp_max = (float)layerBelow.getAgastScore(float(x), y_1, 1);
    if (tmp_max > threshold)
      return 0;
    if (tmp_max > max)
    {
      max = tmp_max;
      max_x = x;
    }
  }
  tmp_max = (float)layerBelow.getAgastScore(x1, y_1, 1);
  if (tmp_max > threshold)
    return 0;
  if (tmp_max > max)
  {
    max = tmp_max;
    max_x = int(x1);
  }

  // middle rows
  for (int y = (int)y_1 + 1; y <= int(y1); y++)
  {
    tmp_max = (float)layerBelow.getAgastScore(x_1, float(y), 1);
    if (tmp_max > threshold)
      return 0;
    if (tmp_max > max)
    {
      max = tmp_max;
      max_x = int(x_1 + 1);
      max_y = y;
    }
    for (int x = (int)x_1 + 1; x <= int(x1); x++)
    {
      tmp_max = (float)layerBelow.getAgastScore(x, y, 1);
      if (tmp_max > threshold)
        return 0;
      if (tmp_max == max)
      {
        const int t1 = 2
            * (layerBelow.getAgastScore(x - 1, y, 1) + layerBelow.getAgastScore(x + 1, y, 1)
               + layerBelow.getAgastScore(x, y + 1, 1) + layerBelow.getAgastScore(x, y - 1, 1))
                       + (layerBelow.getAgastScore(x + 1, y + 1, 1) + layerBelow.getAgastScore(x - 1, y + 1, 1)
                          + layerBelow.getAgastScore(x + 1, y - 1, 1) + layerBelow.getAgastScore(x - 1, y - 1, 1));
        const int t2 = 2
            * (layerBelow.getAgastScore(max_x - 1, max_y, 1) + layerBelow.getAgastScore(max_x + 1, max_y, 1)
               + layerBelow.getAgastScore(max_x, max_y + 1, 1) + layerBelow.getAgastScore(max_x, max_y - 1, 1))
                       + (layerBelow.getAgastScore(max_x + 1, max_y + 1, 1) + layerBelow.getAgastScore(max_x - 1,
                                                                                                       max_y + 1, 1)
                          + layerBelow.getAgastScore(max_x + 1, max_y - 1, 1)
                          + layerBelow.getAgastScore(max_x - 1, max_y - 1, 1));
        if (t1 > t2)
        {
          max_x = x;
          max_y = y;
        }
      }
      if (tmp_max > max)
      {
        max = tmp_max;
        max_x = x;
        max_y = y;
      }
    }
    tmp_max = (float)layerBelow.getAgastScore(x1, float(y), 1);
    if (tmp_max > threshold)
      return 0;
    if (tmp_max > max)
    {
      max = tmp_max;
      max_x = int(x1);
      max_y = y;
    }
  }

  // bottom row
  tmp_max = (float)layerBelow.getAgastScore(x_1, y1, 1);
  if (tmp_max > max)
  {
    max = tmp_max;
    max_x = int(x_1 + 1);
    max_y = int(y1);
  }
  for (int x = (int)x_1 + 1; x <= int(x1); x++)
  {
    tmp_max = (float)layerBelow.getAgastScore(float(x), y1, 1);
    if (tmp_max > max)
    {
      max = tmp_max;
      max_x = x;
      max_y = int(y1);
    }
  }
  tmp_max = (float)layerBelow.getAgastScore(x1, y1, 1);
  if (tmp_max > max)
  {
    max = tmp_max;
    max_x = int(x1);
    max_y = int(y1);
  }

  //find dx/dy:
  int s_0_0 = layerBelow.getAgastScore(max_x - 1, max_y - 1, 1);
  int s_1_0 = layerBelow.getAgastScore(max_x, max_y - 1, 1);
  int s_2_0 = layerBelow.getAgastScore(max_x + 1, max_y - 1, 1);
  int s_2_1 = layerBelow.getAgastScore(max_x + 1, max_y, 1);
  int s_1_1 = layerBelow.getAgastScore(max_x, max_y, 1);
  int s_0_1 = layerBelow.getAgastScore(max_x - 1, max_y, 1);
  int s_0_2 = layerBelow.getAgastScore(max_x - 1, max_y + 1, 1);
  int s_1_2 = layerBelow.getAgastScore(max_x, max_y + 1, 1);
  int s_2_2 = layerBelow.getAgastScore(max_x + 1, max_y + 1, 1);
  float dx_1, dy_1;
  float refined_max = subpixel2D(s_0_0, s_0_1, s_0_2, s_1_0, s_1_1, s_1_2, s_2_0, s_2_1, s_2_2, dx_1, dy_1);

  // calculate dx/dy in above coordinates
  float real_x = float(max_x) + dx_1;
  float real_y = float(max_y) + dy_1;
  bool returnrefined = true;
  if (layer % 2 == 0)
  {
    dx = (float)((real_x * 6.0 + 1.0) / 8.0) - float(x_layer);
    dy = (float)((real_y * 6.0 + 1.0) / 8.0) - float(y_layer);
  }
  else
  {
    dx = (float)((real_x * 4.0 - 1.0) / 6.0) - float(x_layer);
    dy = (float)((real_y * 4.0 - 1.0) / 6.0) - float(y_layer);
  }

  // saturate
  if (dx > 1.0)
  {
    dx = 1.0f;
    returnrefined = false;
  }
  if (dx < -1.0f)
  {
    dx = -1.0f;
    returnrefined = false;
  }
  if (dy > 1.0f)
  {
    dy = 1.0f;
    returnrefined = false;
  }
  if (dy < -1.0f)
  {
    dy = -1.0f;
    returnrefined = false;
  }

  // done and ok.
  ismax = true;
  if (returnrefined)
  {
    return std::max(refined_max, max);
  }
  return max;

}








// construct a layer
BriskLayer1::BriskLayer1(const cv::Mat& img_in, float scale_in, float offset_in)
{
  img_ = img_in;
  scores_ = cv::Mat_<uchar>::zeros(img_in.rows, img_in.cols);
  // attention: this means that the passed image reference must point to persistent memory
  scale_ = scale_in;
  offset_ = offset_in;
  // create an agast detector
  oast_9_16_ = AgastFeatureDetector::create(1, false, AgastFeatureDetector::OAST_9_16);
  makeAgastOffsets1(pixel_5_8_, (int)img_.step);
  makeAgastOffsets2(pixel_9_16_, (int)img_.step);
}


BriskLayer1::BriskLayer1(const BriskLayer1& layer, int mode)
{
  if (mode == CommonParams::HALFSAMPLE)
  {
    img_.create(layer.img().rows / 2, layer.img().cols / 2, CV_8U);
    halfsample(layer.img(), img_);
    scale_ = layer.scale() * 2;
    offset_ = 0.5f * scale_ - 0.5f;
  }

  else
  {
    img_.create(2 * (layer.img().rows / 3), 2 * (layer.img().cols / 3), CV_8U);
    twothirdsample(layer.img(), img_);
    scale_ = layer.scale() * 1.5f;
    offset_ = 0.5f * scale_ - 0.5f;
  }
 scores_ = cv::Mat::zeros(img_.rows, img_.cols, CV_8U);
  oast_9_16_ = AgastFeatureDetector::create(1, false, AgastFeatureDetector::OAST_9_16);
  makeAgastOffsets1(pixel_5_8_, (int)img_.step);
  makeAgastOffsets2(pixel_9_16_, (int)img_.step);
}




void
BriskLayer1::getAgastPoints(int threshold, std::vector<KeyPoint>& keypoints)
{ //cout<<threshold;
  oast_9_16_->setThreshold(threshold);
  oast_9_16_->detect(img_, keypoints);
  //cv::AGAST (img_,keypoints,10,true);
  //cout<<"AGASTPOINTS GETTING\n"<<keypoints.size();
  // also write scores
  const size_t num = keypoints.size();
  cout<<"num"<<num<<"\n";
  for (size_t i = 0; i < num; i++)
    scores_((int)keypoints[i].pt.y, (int)keypoints[i].pt.x) = cv::saturate_cast<uchar>(keypoints[i].response);
}

inline int
BriskLayer1::getAgastScore(int x, int y, int threshold) const
{
  if (x < 3 || y < 3)
    return 0;
  if (x >= img_.cols - 3 || y >= img_.rows - 3)
    return 0;
  uchar& score = (uchar&)scores_(y, x);
  if (score > 2)
  {
    return score;
  }
  score = (uchar) agast_cornerScore11(&img_.at<uchar>(y, x), pixel_9_16_, threshold - 1);
  //cout<<"Score"<<score<<"\n";
  if (score < threshold)
    score = 0;
  return score;
}

inline int
BriskLayer1::getAgastScore_5_8(int x, int y, int threshold) const
{
  if (x < 2 || y < 2)
    return 0;
  if (x >= img_.cols - 2 || y >= img_.rows - 2)
    return 0;
  int score = agast_cornerScore12(&img_.at<uchar>(y, x), pixel_5_8_, threshold - 1);
  //cout<<"Score2"<<score<<"\n";
  if (score < threshold)
    score = 0;
  return score;
}


inline int
BriskLayer1::getAgastScore(float xf, float yf, int threshold_in, float scale_in) const
{
  if (scale_in <= 1.0f)
  {
    // just do an interpolation inside the layer
    const int x = int(xf);
    const float rx1 = xf - float(x);
    const float rx = 1.0f - rx1;
    const int y = int(yf);
    const float ry1 = yf - float(y);
    const float ry = 1.0f - ry1;

    return (uchar)(rx * ry * getAgastScore(x, y, threshold_in) + rx1 * ry * getAgastScore(x + 1, y, threshold_in)
           + rx * ry1 * getAgastScore(x, y + 1, threshold_in) + rx1 * ry1 * getAgastScore(x + 1, y + 1, threshold_in));
  }
  else
  {
    // this means we overlap area smoothing
    const float halfscale = scale_in / 2.0f;
    // get the scores first:
    for (int x = int(xf - halfscale); x <= int(xf + halfscale + 1.0f); x++)
    {
      for (int y = int(yf - halfscale); y <= int(yf + halfscale + 1.0f); y++)
      {
        getAgastScore(x, y, threshold_in);
      }
    }
    // get the smoothed value
    return value(scores_, xf, yf, scale_in);
  }
}


// access gray values (smoothed/interpolated)
inline int
BriskLayer1::value(const cv::Mat& mat, float xf, float yf, float scale_in) const
{
  CV_Assert(!mat.empty());
  // get the position
  const int x = cvFloor(xf);
  const int y = cvFloor(yf);
  const cv::Mat& image = mat;
  const int& imagecols = image.cols;

  // get the sigma_half:
  const float sigma_half = scale_in / 2;
  const float area = 4.0f * sigma_half * sigma_half;
  // calculate output:
  int ret_val;
  if (sigma_half < 0.5)
  {
    //interpolation multipliers:
    const int r_x = (int)((xf - x) * 1024);
    const int r_y = (int)((yf - y) * 1024);
    const int r_x_1 = (1024 - r_x);
    const int r_y_1 = (1024 - r_y);
    const uchar* ptr = image.ptr() + x + y * imagecols;
    // just interpolate:
    ret_val = (r_x_1 * r_y_1 * int(*ptr));
    ptr++;
    ret_val += (r_x * r_y_1 * int(*ptr));
    ptr += imagecols;
    ret_val += (r_x * r_y * int(*ptr));
    ptr--;
    ret_val += (r_x_1 * r_y * int(*ptr));
    return 0xFF & ((ret_val + 512) / 1024 / 1024);
  }



  // this is the standard case (simple, not speed optimized yet):

  // scaling:
  const int scaling = (int)(4194304.0f / area);
  const int scaling2 = (int)(float(scaling) * area / 1024.0f);
  CV_Assert(scaling2 != 0);

  // calculate borders
  const float x_1 = xf - sigma_half;
  const float x1 = xf + sigma_half;
  const float y_1 = yf - sigma_half;
  const float y1 = yf + sigma_half;

  const int x_left = int(x_1 + 0.5);
  const int y_top = int(y_1 + 0.5);
  const int x_right = int(x1 + 0.5);
  const int y_bottom = int(y1 + 0.5);

  // overlap area - multiplication factors:
  const float r_x_1 = float(x_left) - x_1 + 0.5f;
  const float r_y_1 = float(y_top) - y_1 + 0.5f;
  const float r_x1 = x1 - float(x_right) + 0.5f;
  const float r_y1 = y1 - float(y_bottom) + 0.5f;
  const int dx = x_right - x_left - 1;
  const int dy = y_bottom - y_top - 1;
  const int A = (int)((r_x_1 * r_y_1) * scaling);
  const int B = (int)((r_x1 * r_y_1) * scaling);
  const int C = (int)((r_x1 * r_y1) * scaling);
  const int D = (int)((r_x_1 * r_y1) * scaling);
  const int r_x_1_i = (int)(r_x_1 * scaling);
  const int r_y_1_i = (int)(r_y_1 * scaling);
  const int r_x1_i = (int)(r_x1 * scaling);
  const int r_y1_i = (int)(r_y1 * scaling);

  // now the calculation:
  const uchar* ptr = image.ptr() + x_left + imagecols * y_top;
  // first row:
  ret_val = A * int(*ptr);
  ptr++;
  const uchar* end1 = ptr + dx;
  for (; ptr < end1; ptr++)
  {
    ret_val += r_y_1_i * int(*ptr);
  }
  ret_val += B * int(*ptr);
  // middle ones:
  ptr += imagecols - dx - 1;
  const uchar* end_j = ptr + dy * imagecols;
  for (; ptr < end_j; ptr += imagecols - dx - 1)
  {
    ret_val += r_x_1_i * int(*ptr);
    ptr++;
    const uchar* end2 = ptr + dx;
    for (; ptr < end2; ptr++)
    {
      ret_val += int(*ptr) * scaling;
    }
    ret_val += r_x1_i * int(*ptr);
  }
  // last row:
  ret_val += D * int(*ptr);
  ptr++;
  const uchar* end3 = ptr + dx;
  for (; ptr < end3; ptr++)
  {
    ret_val += r_y1_i * int(*ptr);
  }
  ret_val += C * int(*ptr);

  return 0xFF & ((ret_val + scaling2 / 2) / scaling2 / 1024);
}


inline void
BriskLayer1::halfsample(const cv::Mat& srcimg, cv::Mat& dstimg)
{
  // make sure the destination image is of the right size:
  CV_Assert(srcimg.cols / 2 == dstimg.cols);
  CV_Assert(srcimg.rows / 2 == dstimg.rows);

  // handle non-SSE case
  resize(srcimg, dstimg, dstimg.size(), 0, 0, cv::INTER_AREA);
}

inline void
BriskLayer1::twothirdsample(const Mat& srcimg, cv::Mat& dstimg)
{
  // make sure the destination image is of the right size:
  CV_Assert((srcimg.cols / 3) * 2 == dstimg.cols);
  CV_Assert((srcimg.rows / 3) * 2 == dstimg.rows);

  resize(srcimg, dstimg, dstimg.size(), 0, 0, cv::INTER_AREA);
}

const double kDistanceCoef = 4.0;
const int kMaxMatchingSize = 50;
inline void match( Mat& desc1, Mat& desc2, vector<DMatch>& matches) {
    matches.clear();

        BFMatcher desc_matcher(cv::NORM_L2, true);
        vector< vector<DMatch> > vmatches;
        desc_matcher.knnMatch(desc1, desc2, vmatches, 1);
        for (int i = 0; i < static_cast<int>(vmatches.size()); ++i) {
            if (!vmatches[i].size()) {
                continue;
            }
            matches.push_back(vmatches[i][0]);
        }

    std::sort(matches.begin(), matches.end());
    while (matches.front().distance * kDistanceCoef < matches.back().distance) {
        matches.pop_back();
    }
    while (matches.size() > kMaxMatchingSize) {
        matches.pop_back();
    }
}

inline void findKeyPointsHomography(vector<KeyPoint>& kpts1, vector<KeyPoint>& kpts2,
        vector<DMatch>& matches, vector<char>& match_mask) {
    if (static_cast<int>(match_mask.size()) < 3) {
        return;
    }
    vector<Point2f> pts1;
    vector<Point2f> pts2;
    for (int i = 0; i < static_cast<int>(matches.size()); ++i) {
        pts1.push_back(kpts1[matches[i].queryIdx].pt);
        pts2.push_back(kpts2[matches[i].trainIdx].pt);
    }
    findHomography(pts1, pts2, cv::RANSAC, 4, match_mask);
}



int main(int argc, char** argv) {
  /* MPI_Init(NULL,NULL);
    int rank,size;
   MPI_Comm_size(MPI_COMM_WORLD,&size);
   MPI_Comm_rank(MPI_COMM_WORLD,&rank);
  */
   int n=4;

    Mat img1 = cv::imread("Img1.jpg", CV_LOAD_IMAGE_COLOR);
    resize(img1, img1, cv::Size(img1.cols/4, img1.rows/4));

    if (img1.channels() != 1) {
        cvtColor(img1, img1, cv::COLOR_RGB2GRAY);
    }
      vector<KeyPoint> kpts1;
      Mat desc1;
      BRISK_Impl1 a1=BRISK_Impl1(20,1,1.0);
      a1.detectAndCompute(img1, Mat(), kpts1, desc1,1);

     if(1)
      {int max=0;
      string Final_img;
           for(char i=0;i<n/2;i++)
             {
               string img_name=".jpg";
              //  img_name=img_name+".jpg";
          //     img_name=img_name+".png";
          //     //char img_name[20]="image";
          //     //char *ii;
            cout<<i+img_name;
              //cout<<"Img_name\n"<<img_name;
                Mat img = cv::imread("0.jpg", CV_LOAD_IMAGE_COLOR);
                //resize(img, img, cv::Size(img1.cols/4, img1.rows/4));

                if (img.channels() != 1) {
                    cvtColor(img, img, cv::COLOR_RGB2GRAY);
              }
            vector<KeyPoint> kpts;
            Mat desc;
            BRISK_Impl1 a2=BRISK_Impl1(20,1,1.0);
            a2.detectAndCompute(img, Mat(), kpts, desc,1);
              vector<DMatch> matches;

            match(desc1, desc, matches);
           
            if(matches.size()>max)
                {
                  max=matches.size();
                 Final_img=i+img_name;
                }
            vector<char> match_mask(matches.size(), 1);
            findKeyPointsHomography(kpts1, kpts, matches, match_mask);
            //cout<<desc.size();
            Mat res;
            cv::drawMatches(img1, kpts1, img, kpts, matches, res, Scalar::all(-1),
                Scalar::all(-1), match_mask, DrawMatchesFlags::NOT_DRAW_SINGLE_POINTS);
              cout<<"\n"<<"MATCHES"<<matches.size()<<"\n";
            cv::imshow("result", res);
            cv::waitKey(0);

          }
          cout<<Final_img;
     }
     //else
     {
       for(int i=n/2;i<n;i++)
         {
            // char img_name[20]="image";
            // strcat(img_name,i);
            // strcat(img_name,".png");
              Mat img = cv::imread("pdp.jpg", CV_LOAD_IMAGE_COLOR);
             //resize(img, img, cv::Size(img.cols/4, img.rows/4));
             cout<<"hey";
             if (img.channels() != 1) {
                 cvtColor(img, img, cv::COLOR_RGB2GRAY);
           }
         vector<KeyPoint> kpts;
         Mat desc;
         BRISK_Impl1 a2=BRISK_Impl1(20,1,1.0);
         a2.detectAndCompute(img, Mat(), kpts, desc,1);

         vector<DMatch> matches;

         match(desc1, desc, matches);
         cout<<"\nMatches"<<matches.size()<<"\n";
         vector<char> match_mask(matches.size(), 1);
         findKeyPointsHomography(kpts1, kpts, matches, match_mask);
         //cout<<desc.size();
         Mat res;
         cv::drawMatches(img1, kpts1, img, kpts, matches, res, Scalar::all(-1),
             Scalar::all(-1), match_mask, DrawMatchesFlags::NOT_DRAW_SINGLE_POINTS);

         cv::imshow("result", res);
         cv::waitKey(0);
       }
    }
//MPI_Finalize();
    return 0;
}



